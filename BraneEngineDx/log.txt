[Log][0:0:0:166]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
void main()
{
    mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    vec4 _WorldPos = fm * vec4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:0:167]Default_Default.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:171]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    vec4 _WorldPos = fm * vec4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:0:172]Default_Default.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:177]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
layout (std430, binding = MORPHDATA_BIND_INDEX) buffer CB1
{
    vec4 nMorphV;
    vec4 morphData[];
};
layout (std430, binding = MORPHWEIGHT_BIND_INDEX) buffer CB2
{
    float morphWeight[];
};
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
vec3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}
vec3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    vec4 _WorldPos = fm * vec4(morphPos(), 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * morphNorm());
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:0:177]Default_Default.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Default.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:178]Engine/Shaders/Default/Default_Default.shadapter load
[Log][0:0:0:181]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
uniform float borderWidth;
uniform float refenceDistance;
void main()
{
    mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    float sca = 1;
    if (refenceDistance != 0) {
        vec3 vec = (fm * vec4(pos, 1.0)).xyz - camData.camPos;
        float dist = dot(vec, camData.camDir);
        sca = dist / refenceDistance;
    }
    gl_Position = camData.pmat * fm * vec4(pos + borderWidth * sca * normalize(norm), 1.0);
}

[Error][0:0:0:181]Default_Outline.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:185]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
uniform float borderWidth;
uniform float refenceDistance;
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    float sca = 1;
    if (refenceDistance != 0) {
        vec3 vec = (fm * vec4(pos, 1.0)).xyz - camData.camPos;
        float dist = dot(vec, camData.camDir);
        sca = dist / refenceDistance;
    }
    gl_Position = camData.pmat * fm * vec4(pos + borderWidth * sca * normalize(norm), 1.0);
}

[Error][0:0:0:185]Default_Outline.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:189]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
layout (std430, binding = MORPHDATA_BIND_INDEX) buffer CB1
{
    vec4 nMorphV;
    vec4 morphData[];
};
layout (std430, binding = MORPHWEIGHT_BIND_INDEX) buffer CB2
{
    float morphWeight[];
};
uniform float borderWidth;
uniform float refenceDistance;
vec3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}
vec3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    vec3 mpos = morphPos();
    vec3 mnorm = morphNorm();
    float sca = 1;
    if (refenceDistance != 0) {
        vec3 vec = (fm * vec4(mpos, 1.0)).xyz - camData.camPos;
        float dist = dot(vec, camData.camDir);
        sca = dist / refenceDistance;
    }
    gl_Position = camData.pmat * fm * vec4(mpos + borderWidth * sca * normalize(mnorm), 1.0);
}

[Error][0:0:0:190]Default_Outline.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Outline.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:190]Engine/Shaders/Default/Default_Outline.shadapter load
[Log][0:0:0:192]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
layout (std430, binding = PARTICLE_BIND_INDEX) buffer ParticleBuffer
{
    Particle Particles[];
};
out Particle gParticle;
out uint index;
void main()
{
    index = gl_InstanceID + gl_BaseInstance;
    gParticle = Particles[index];
    //gl_Position = vec4(gParticle.pos, 1.0);
}

[Error][0:0:0:192]Default_Particle.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Particle.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Particle.shadapter(13,5-8): error X3000: unrecognized identifier 'vec3'

[Log][0:0:0:197]Geometry Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
layout (std430, binding = PARTICLE_BIND_INDEX) buffer ParticleBuffer
{
    Particle Particles[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (points) in;
layout (triangle_strip, max_vertices = 4) out;
in Particle gParticle[];
in uint index[];
uniform float uvScale;
out Particle particle;
out vec2 UV;
vec3 lineCross(vec3 a1, vec3 b1, vec3 a2, vec3 b2)
{
    vec3 p1 = a1, p2 = a2;
    vec3 d1 = b1 - a1, d2 = b2 - a2;
    vec3 ans1, ans2;
    float t1, t2;
    t1 = dot((cross(p2 - p1, d2)), cross(d1, d2));
    t2 = dot((cross(p2 - p1, d1)), cross(d1, d2));
    float dd = length((cross(d1, d2)));
    t1 /= dd * dd;
    t2 /= dd * dd;
    ans1 = (a1 + (b1 - a1) * t1);
    ans2 = (a2 + (b2 - a2) * t2);
    return (ans1 + ans2) / 2.0;
}
vec3 calH(uint i)
{
    if (i == 0 && Particles[i].extSca == 1)
        return vec3(0, 0, 0);
    if (i == 0) {
        vec3 v = Particles[i + 1].pos - Particles[i].pos;
        return normalize(cross(v, Particles[i].pos - camData.camPos)) * Particles[i].scale.x;
    }
    else if (Particles[i].extSca == 1) {
        vec3 v = Particles[i].pos - Particles[i - 1].pos;
        return normalize(cross(v, Particles[i].pos - camData.camPos)) * Particles[i].scale.x;
    }
    else {
        vec3 v0 = Particles[i].pos - Particles[i - 1].pos;
        vec3 v1 = Particles[i + 1].pos - Particles[i].pos;
        vec3 cv0 = (Particles[i - 1].pos + Particles[i].pos) / 2.0 - camData.camPos;
        vec3 cv1 = (Particles[i].pos + Particles[i + 1].pos) / 2.0 - camData.camPos;
        vec3 v = normalize(v0) + normalize(v1);
        vec3 cv = normalize(cv0) + normalize(cv1);
        return normalize(cross(v, cv)) * Particles[i].scale.x;
    }
}
void main()
{
    particle = gParticle[0];
    vec3 v;
    vec3 h0, h1;
    vec3 pos0, pos1;
    if (particle.type == 0) {
        v = camData.camUp * particle.scale.y * 0.5;
        h0 = h1 = camData.camLeft * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 1) {
        v = normalize(particle.velocity) * particle.scale.y * 0.5;
        h0 = h1 = normalize(cross(particle.velocity, particle.pos - camData.camPos)) * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 2) {
        v = (particle.extVec.xyz - particle.pos) * particle.scale.y * (particle.maxLifetime == 0 ?
        1 : clamp((1 - particle.lifetime / particle.maxLifetime) / particle.extVec.w, 0, 1));
        h0 = h1 = normalize(cross(v, particle.pos - camData.camPos)) * particle.scale.x * 0.5;
        pos0 = particle.pos;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 3) {
        if (Particles[index[0]].extSca == 1)
            return;
        h0 = calH(index[0]);
        h1 = calH(index[0] + 1);
        pos0 = particle.pos;
        pos1 = Particles[index[0] + 1].pos;
    }
    else {
        v = camData.camUp * particle.scale.y * 0.5;
        h0 = h1 = camData.camLeft * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }
    float uvS = uvScale == 0 ? 1 : (uvScale * length(pos1 - pos0) / length(h0 + h1) * 2.0);
    gl_Position = camData.pmat * vec4(pos0 + h0, 1.0);
    UV = vec2(0, 0);
    EmitVertex();
    gl_Position = camData.pmat * vec4(pos0 - h0, 1.0);
    UV = vec2(1, 0);
    EmitVertex();
    gl_Position = camData.pmat * vec4(pos1 + h1, 1.0);
    UV = vec2(0, uvS);
    EmitVertex();
    gl_Position = camData.pmat * vec4(pos1 - h1, 1.0);
    UV = vec2(1, uvS);
    EmitVertex();
    EndPrimitive();
}

[Error][0:0:0:197]Default_Particle.shadapter (Geometry Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Particle.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Particle.shadapter(13,5-8): error X3000: unrecognized identifier 'vec3'

[Log][0:0:0:197]Engine/Shaders/Default/Default_Particle.shadapter load
[Log][0:0:0:200]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
void main()
{
    gl_Position = camData.pmat * Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]] * vec4(pos, 1.0);
}

[Error][0:0:0:201]Default_Position.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:204]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    gl_Position = camData.pmat * getFinalMat() * vec4(pos, 1.0);
}

[Error][0:0:0:204]Default_Position.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:209]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
layout (std430, binding = MORPHDATA_BIND_INDEX) buffer CB1
{
    vec4 nMorphV;
    vec4 morphData[];
};
layout (std430, binding = MORPHWEIGHT_BIND_INDEX) buffer CB2
{
    float morphWeight[];
};
vec3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}
vec3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    vec4 worldPos = getFinalMat() * vec4(morphPos(), 1.0);
    gl_Position = camData.pmat * worldPos;
}

[Error][0:0:0:209]Default_Position.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_Position.shadapter(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:209]Engine/Shaders/Default/Default_Position.shadapter load
[Log][0:0:0:210]Vertex Shader
#version 460 core
const vec2 quadVertices[4] = vec2[](vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0));
const vec2 quadUV[4] = vec2[](vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0));
out vec2 UV;
void main()
{
    gl_Position = vec4(quadVertices[gl_VertexID], 0.0, 1.0);
    UV = quadUV[gl_VertexID];
}

[Error][0:0:0:210]Default_PostProcess.shadapter (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_PostProcess.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default_PostProcess.shadapter(2,7-10): error X3000: unrecognized identifier 'vec2'

[Log][0:0:0:210]Engine/Shaders/Default/Default_PostProcess.shadapter load
[Log][0:0:0:211]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
void main()
{
}

[Error][0:0:0:211]Empty_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Empty_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Empty_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:211]Engine/Shaders/Default/Empty_Fragment.shadapter load
[Log][0:0:0:221]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
void main() {
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    vec3 albedo = baseColor.rgb * texture(colorMap, TexCoords).rgb;
    float alpha = baseColor.a * texture(colorMap, TexCoords).a;
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    vec3 ambient = PBR_Ambient(albedo, _ao);
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    FragColor = vec4(color, alpha);
}

[Error][0:0:0:221]PBR_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:221]Engine/Shaders/Default/PBR_Fragment.shadapter load
[Log][0:0:0:232]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform vec4 reflectionColor;
uniform sampler2D reflectionMap;
uniform sampler2D irradianceMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D brdfLUT;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
void main() {
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    vec3 albedo = baseColor.rgb * texture(colorMap, TexCoords).rgb;
    float alpha = baseColor.a * texture(colorMap, TexCoords).a;
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    // IBL
    vec3 L = normalize(-reflect(-V, N));
    vec3 H = normalize(L + V);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0, _roughness);
    vec3 kD = 1.0 - F;
    kD *= 1.0 - metallic;
    vec2 coord = sphereProj(-L);
    coord.y = 1 - coord.y;
    vec3 rel = textureLod(reflectionMap, coord, _roughness * (textureQueryLevels(reflectionMap) - 1)).xyz;
    vec3 irrad = texture(irradianceMap, coord).xyz;
    coord = vec2(max(dot(N, V), 0.0), _roughness);
    coord.y = 1 - coord.y;
    vec2 envBRDF = texture(brdfLUT, coord).rg;
    vec3 Le = rel * (F * envBRDF.x + envBRDF.y);
    vec3 iblAmbient = kD * irrad * albedo + Le;
    vec3 pbrAmbient = vec3(0.03) * albedo;
    // Combination
    vec3 ambient = (pbrAmbient + iblAmbient * reflectionColor.xyz) * _ao;
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    FragColor = vec4(color, alpha);
}

[Error][0:0:0:232]PBR_IBL_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:232]Engine/Shaders/Default/PBR_IBL_Fragment.shadapter load
[Log][0:0:0:233]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
uniform vec4 baseColor;
layout (location = 0) out vec4 FragColor;
void main()
{
    FragColor = baseColor;
}

[Error][0:0:0:233]PureColor_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PureColor_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PureColor_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:233]Engine/Shaders/Default/PureColor_Fragment.shadapter load
[Log][0:0:0:241]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
//layout (location = 1) out vec4 ssnMask;
in vec3 Normal;
in vec2 TexCoords;
in vec4 lightSpacePos;
in vec3 WorldPos;
uniform vec4 baseColor;
uniform vec4 shadowColor;
uniform vec4 highlightColor;
uniform vec4 rimColor;
uniform vec4 overColor;
uniform float shadowCut;
uniform float shadowCutSmooth;
uniform float highlightCut;
uniform float highlightCutSmooth;
uniform float rimCut;
uniform float rimCutSmooth;
uniform float normalScale;
uniform sampler2D colorMap;
uniform sampler2D aoMap;
uniform sampler2D normalMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
vec4 smoothToon(vec4 base, vec4 over, float value, float cut, float smoothValue)
{
    float hs = clamp(smoothValue, 0.0f, 1.0f) / 2.0f;
    return mix(over, base, smoothstep(max(0.0f, cut - hs), min(1.0f, cut + hs), value));
}
float ShadowCalculation(vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.00005 * (1.0 - dot(N, L)), 0.000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;
        }
    }
    shadow /= 49.0;
    return shadow;
}
void main()
{
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale);
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 albedo = texture(colorMap, TexCoords);
    vec4 ao = texture(aoMap, TexCoords);
    float a = albedo.a * baseColor.a;
    vec3 L = normalize(directLight.direction);
    vec3 H = normalize(V + L);
    vec4 ambience = mix(baseColor, highlightColor, smoothToon(vec4(1.0f), vec4(0.0f), dot(N, H), highlightCut, highlightCutSmooth));
    ambience = mix(shadowColor, ambience, ShadowCalculation(lightSpacePos, N, L));
    ambience = smoothToon(ambience, shadowColor, dot(N, L), shadowCut, shadowCutSmooth);
    ambience = smoothToon(rimColor, ambience, fresnelSchlick(dot(N, normalize(camData.camPos - WorldPos)), 0.33f), rimCut, rimCutSmooth);
    FragColor = albedo * ambience * ao;
    FragColor.a = a;
    FragColor *= overColor;
    //ssnMask = vec4(1);
}

[Error][0:0:0:241]Toon_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:242]Engine/Shaders/Default/Toon_Fragment.shadapter load
[Log][0:0:0:249]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
//layout (location = 1) out vec4 ssnMask;
in vec3 Normal;
in vec2 TexCoords;
in vec4 lightSpacePos;
in vec3 WorldPos;
uniform vec4 baseColor;
uniform vec4 reflectionColor;
uniform vec4 shadowColor;
uniform vec4 highlightColor;
uniform vec4 rimColor;
uniform vec4 overColor;
uniform float shadowCut;
uniform float shadowCutSmooth;
uniform float highlightCut;
uniform float highlightCutSmooth;
uniform float rimCut;
uniform float rimCutSmooth;
uniform float normalScale;
uniform float roughness;
uniform sampler2D colorMap;
uniform sampler2D aoMap;
uniform sampler2D roughnessMap;
uniform sampler2D reflectionMap;
uniform sampler2D normalMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
vec4 smoothToon(vec4 base, vec4 over, float value, float cut, float smoothValue)
{
    float hs = clamp(smoothValue, 0.0f, 1.0f) / 2.0f;
    return mix(over, base, smoothstep(max(0.0f, cut - hs), min(1.0f, cut + hs), value));
}
float ShadowCalculation(vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.00005 * (1.0 - dot(N, L)), 0.000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;
        }
    }
    shadow /= 49.0;
    return shadow;
}
void main()
{
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale);
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 albedo = texture(colorMap, TexCoords);
    vec4 ao = texture(aoMap, TexCoords);
    float a = albedo.a * baseColor.a;
    vec3 L = normalize(directLight.direction);
    vec3 H = normalize(V + L);
    vec4 ambience = mix(baseColor, highlightColor, smoothToon(vec4(1.0f), vec4(0.0f), dot(N, H), highlightCut, highlightCutSmooth));
    ambience = mix(shadowColor, ambience, ShadowCalculation(lightSpacePos, N, L));
    ambience = smoothToon(ambience, shadowColor, dot(N, L), shadowCut, shadowCutSmooth);
    ambience = smoothToon(rimColor, ambience, fresnelSchlick(dot(N, normalize(camData.camPos - WorldPos)), 0.33f), rimCut, rimCutSmooth);
    vec3 R = normalize(-reflect(-V, N));
    float _roughness = texture(roughnessMap, TexCoords).r * roughness;
    vec2 coord = sphereProj(-R);
    coord.y = 1 - coord.y;
    vec4 rel = textureLod(reflectionMap, coord, _roughness * (textureQueryLevels(reflectionMap) - 1));
    FragColor = mix(reflectionColor * rel, albedo, _roughness) * ambience * ao;
    FragColor.a = a;
    FragColor *= overColor;
    //ssnMask = vec4(1);
}

[Error][0:0:0:250]Toon_IBL_Fragment.shadapter (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_IBL_Fragment.shadapter(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_IBL_Fragment.shadapter(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:250]Engine/Shaders/Default/Toon_IBL_Fragment.shadapter load
[Log][0:0:0:251]Geometry Shader
#version 410 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;
out vec3 dist;
void main()
{
   vec2 s = vec2(1920, 1080) / 2;
   vec2 p0 = gl_in[0].gl_Position.xy / gl_in[0].gl_Position.w;
   vec2 p1 = gl_in[1].gl_Position.xy / gl_in[1].gl_Position.w;
   vec2 p2 = gl_in[2].gl_Position.xy / gl_in[2].gl_Position.w;
   vec2 v1 = s * (p1 - p0);
   vec2 v2 = s * (p2 - p0);
   vec2 v0 = s * (p2 - p1);
   float c = abs(v1.x * v2.y - v1.y * v2.x);
   float h = c / length(v0);
   dist = vec3(h, 0, 0);
   dist *= gl_in[0].gl_Position.w;
   gl_Position = gl_in[0].gl_Position;
   EmitVertex();
   h = c / length(v1);
   dist = vec3(0, h, 0);
   dist *= gl_in[1].gl_Position.w;
   gl_Position = gl_in[1].gl_Position;
   EmitVertex();
   h = c / length(v2);
   dist = vec3(0, 0, h);
   dist *= gl_in[2].gl_Position.w;
   gl_Position = gl_in[2].gl_Position;
   EmitVertex();
   EndPrimitive();
}

[Error][0:0:0:252]Default.mat (Geometry Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:252]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
uniform vec4 baseColor;
uniform vec4 outlineColor;
in vec3 dist;
layout (location = 0) out vec4 FragColor;
void main()
{
   float d = min(dist[0], min(dist[1], dist[2])) * gl_FragCoord.w * 2;
   float I = exp2(-0.5 * d);
   FragColor = mix(baseColor, outlineColor, I);
}

[Error][0:0:0:252]Default.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:254]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
uniform sampler2D colorMap;
uniform sampler2D noiseMap;
in Particle particle;
in vec2 UV;
layout (location = 0) out vec4 FragColor;
void main()
{
    FragColor = particle.color * texture(colorMap, UV);
    FragColor.a = FragColor.a * texture(noiseMap, UV).r;
}

[Error][0:0:0:254]Particle.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:0:310]Engine/Banner folder
[Log][0:0:0:359]Engine/Banner/Banner.png load
[Log][0:0:0:392]Engine/Banner/Banne_old.png load
[Log][0:0:0:392]Engine/Fonts folder
[Log][0:0:0:393]Engine/Icons folder
[Log][0:0:0:398]Engine/Icons/Animation_Icon.png load
[Log][0:0:0:422]Engine/Icons/AssetFile_Icon.png load
[Log][0:0:0:440]Engine/Icons/Audio_Icon.png load
[Log][0:0:0:449]Engine/Icons/Folder_Icon.png load
[Log][0:0:0:459]Engine/Icons/Material_Icon.png load
[Log][0:0:0:479]Engine/Icons/Model_Icon.png load
[Log][0:0:0:492]Engine/Icons/Python_Icon.png load
[Log][0:0:0:509]Engine/Icons/SkeletonMesh_Icon.png load
[Log][0:0:0:509]Engine/LUTS folder
[Log][0:0:0:578]Engine/LUTS/arapaho_lut.png load
[Log][0:0:0:648]Engine/LUTS/aspen_lut.png load
[Log][0:0:0:719]Engine/LUTS/BlacKkKlansman_lut.png load
[Log][0:0:0:788]Engine/LUTS/bluegreen_lut.png load
[Log][0:0:0:858]Engine/LUTS/C-8120-STD_lut.png load
[Log][0:0:0:929]Engine/LUTS/C-9730-STD_lut.png load
[Log][0:0:0:997]Engine/LUTS/darkest_hour_lut.png load
[Log][0:0:1:64]Engine/LUTS/F-6800-STD_lut.png load
[Log][0:0:1:132]Engine/LUTS/F-8700-STD_lut.png load
[Log][0:0:1:198]Engine/LUTS/F-8700-V2-STD_lut.png load
[Log][0:0:1:266]Engine/LUTS/greygreen_lut.png load
[Log][0:0:1:335]Engine/LUTS/H-9110-STD_lut.png load
[Log][0:0:1:401]Engine/LUTS/humble_lut.png load
[Log][0:0:1:466]Engine/LUTS/kodak-5205-fuji_lut.png load
[Log][0:0:1:538]Engine/LUTS/oldman_lut.png load
[Log][0:0:1:607]Engine/LUTS/sedona_lut.png load
[Log][0:0:1:673]Engine/LUTS/W-8370-STD_lut.png load
[Log][0:0:1:740]Engine/LUTS/W-ARAPAHO-33-STD_lut.png load
[Log][0:0:1:803]Engine/LUTS/X-6500-STD_lut.png load
[Log][0:0:1:869]Engine/LUTS/X-9400-STD_lut.png load
[Log][0:0:1:870]Engine/Shaders folder
[Log][0:0:1:871]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
layout (location = 0) out vec4 FragColor;
void main()
{
   FragColor = vec4(0, 0, 0, 1);
}

[Error][0:0:1:871]BlackLit.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlackLit.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlackLit.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:871]Engine/Shaders/BlackLit.mat load
[Log][0:0:1:872]Engine/Shaders/ClearColor.mat load
[Log][0:0:1:872]Engine/Shaders/Default folder
[Warn][0:0:1:873]Engine/Shaders/Default/Default_Default.shadapter unknown file type
[Error][0:0:1:873]Engine/Shaders/Default/Default_Default.shadapter Default_Default load failed
[Warn][0:0:1:873]Engine/Shaders/Default/Default_Outline.shadapter unknown file type
[Error][0:0:1:873]Engine/Shaders/Default/Default_Outline.shadapter Default_Outline load failed
[Warn][0:0:1:873]Engine/Shaders/Default/Default_Particle.shadapter unknown file type
[Error][0:0:1:874]Engine/Shaders/Default/Default_Particle.shadapter Default_Particle load failed
[Warn][0:0:1:874]Engine/Shaders/Default/Default_Position.shadapter unknown file type
[Error][0:0:1:874]Engine/Shaders/Default/Default_Position.shadapter Default_Position load failed
[Warn][0:0:1:874]Engine/Shaders/Default/Default_PostProcess.shadapter unknown file type
[Error][0:0:1:874]Engine/Shaders/Default/Default_PostProcess.shadapter Default_PostProcess load failed
[Warn][0:0:1:875]Engine/Shaders/Default/Empty_Fragment.shadapter unknown file type
[Error][0:0:1:875]Engine/Shaders/Default/Empty_Fragment.shadapter Empty_Fragment load failed
[Warn][0:0:1:875]Engine/Shaders/Default/PBR_Fragment.shadapter unknown file type
[Error][0:0:1:875]Engine/Shaders/Default/PBR_Fragment.shadapter PBR_Fragment load failed
[Warn][0:0:1:876]Engine/Shaders/Default/PBR_IBL_Fragment.shadapter unknown file type
[Error][0:0:1:876]Engine/Shaders/Default/PBR_IBL_Fragment.shadapter PBR_IBL_Fragment load failed
[Warn][0:0:1:876]Engine/Shaders/Default/PureColor_Fragment.shadapter unknown file type
[Error][0:0:1:876]Engine/Shaders/Default/PureColor_Fragment.shadapter PureColor_Fragment load failed
[Warn][0:0:1:877]Engine/Shaders/Default/Toon_Fragment.shadapter unknown file type
[Error][0:0:1:877]Engine/Shaders/Default/Toon_Fragment.shadapter Toon_Fragment load failed
[Warn][0:0:1:877]Engine/Shaders/Default/Toon_IBL_Fragment.shadapter unknown file type
[Error][0:0:1:877]Engine/Shaders/Default/Toon_IBL_Fragment.shadapter Toon_IBL_Fragment load failed
[Log][0:0:1:879]Geometry Shader
#version 410 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;
out vec3 dist;
void main()
{
   vec2 s = vec2(1920, 1080) / 2;
   vec2 p0 = gl_in[0].gl_Position.xy / gl_in[0].gl_Position.w;
   vec2 p1 = gl_in[1].gl_Position.xy / gl_in[1].gl_Position.w;
   vec2 p2 = gl_in[2].gl_Position.xy / gl_in[2].gl_Position.w;
   vec2 v1 = s * (p1 - p0);
   vec2 v2 = s * (p2 - p0);
   vec2 v0 = s * (p2 - p1);
   float c = abs(v1.x * v2.y - v1.y * v2.x);
   float h = c / length(v0);
   dist = vec3(h, 0, 0);
   dist *= gl_in[0].gl_Position.w;
   gl_Position = gl_in[0].gl_Position;
   EmitVertex();
   h = c / length(v1);
   dist = vec3(0, h, 0);
   dist *= gl_in[1].gl_Position.w;
   gl_Position = gl_in[1].gl_Position;
   EmitVertex();
   h = c / length(v2);
   dist = vec3(0, 0, h);
   dist *= gl_in[2].gl_Position.w;
   gl_Position = gl_in[2].gl_Position;
   EmitVertex();
   EndPrimitive();
}

[Error][0:0:1:879]Default.mat (Geometry Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:880]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
uniform vec4 baseColor;
uniform vec4 outlineColor;
in vec3 dist;
layout (location = 0) out vec4 FragColor;
void main()
{
   float d = min(dist[0], min(dist[1], dist[2])) * gl_FragCoord.w * 2;
   float I = exp2(-0.5 * d);
   FragColor = mix(baseColor, outlineColor, I);
}

[Error][0:0:1:880]Default.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Default.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:880]Engine/Shaders/Default.mat load
[Log][0:0:1:881]Engine/Shaders/Depth.mat load
[Log][0:0:1:886]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
uniform float time;
uniform float windDensity;
uniform vec4 windForce;
vec2 random2(vec2 st){
    st = vec2( dot(st,vec2(127.1,311.7)),
              dot(st,vec2(269.5,183.3)) );
    return -1.0 + 2.0*fract(sin(st)*43758.5453123);
}
float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    vec2 u = f*f*(3.0-2.0*f);
    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),
                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),
                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
}
void main() {
    mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    vec4 _WorldPos = fm * vec4(pos, 1.0);
    vec2 offset = (noise((_WorldPos.xz + time * normalize(windForce.xy)) *
        windDensity) - 0.5) * windForce.xy;
    
    _WorldPos.xy += offset * uv.y;
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:1:887]Grass_Toon.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Grass_Toon.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Grass_Toon.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:893]Fragment Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
vec4 smoothToon(vec4 base, vec4 over, float value, float cut, float smoothValue)
{
    float hs = clamp(smoothValue, 0.0f, 1.0f) / 2.0f;
    return mix(over, base, smoothstep(max(0.0f, cut - hs), min(1.0f, cut + hs), value));
}
const mat4 thresholdMatrix = mat4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);
layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 ssnMask;
in vec3 Normal;
in vec2 TexCoords;
in vec4 lightSpacePos;
in vec3 WorldPos;
uniform float noiseUVScale;
uniform float lightFactor;
uniform float darkCut;
uniform float darkSmooth;
uniform float alphaCut;
uniform vec4 baseColor;
uniform vec4 darkColor;
uniform vec4 shadowColor;
uniform vec4 noiseColor;
uniform vec4 overColor;
uniform sampler2D colorMap;
uniform sampler2D noiseMap;
uniform sampler2D depthMap;
void main() {
    vec4 color = texture(colorMap, TexCoords);
    if (color.a < alphaCut)
        discard;
    vec3 L = normalize(directLight.direction);
    vec4 ambience = smoothToon(darkColor, baseColor, TexCoords.y, darkCut, darkSmooth);
    ambience.rgb *= mix(vec3(1), directLight.color, lightFactor);
    float shadowFactor = ShadowCalculation(depthMap, lightSpacePos, Normal, L);
    ambience = mix(shadowColor, ambience, shadowFactor);
    ambience *= mix(overColor, noiseColor, texture(noiseMap, WorldPos.xy / noiseUVScale));
    
    FragColor = color * ambience;
    ssnMask = vec4(1);
}

[Error][0:0:1:893]Grass_Toon.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Grass_Toon.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Grass_Toon.mat(13,5-8): error X3000: unrecognized identifier 'vec3'

[Log][0:0:1:894]Engine/Shaders/Grass_Toon.mat load
[Log][0:0:1:894]Engine/Shaders/lib folder
[Warn][0:0:1:894]Engine/Shaders/lib/Basic_FS_Lib.hmat unknown file type
[Error][0:0:1:894]Engine/Shaders/lib/Basic_FS_Lib.hmat Basic_FS_Lib load failed
[Warn][0:0:1:895]Engine/Shaders/lib/Basic_VS_Lib.hmat unknown file type
[Error][0:0:1:895]Engine/Shaders/lib/Basic_VS_Lib.hmat Basic_VS_Lib load failed
[Warn][0:0:1:895]Engine/Shaders/lib/Bindings_Def.hmat unknown file type
[Error][0:0:1:895]Engine/Shaders/lib/Bindings_Def.hmat Bindings_Def load failed
[Warn][0:0:1:895]Engine/Shaders/lib/CameraData_Def.hmat unknown file type
[Error][0:0:1:896]Engine/Shaders/lib/CameraData_Def.hmat CameraData_Def load failed
[Warn][0:0:1:896]Engine/Shaders/lib/Const_Def.hmat unknown file type
[Error][0:0:1:896]Engine/Shaders/lib/Const_Def.hmat Const_Def load failed
[Warn][0:0:1:896]Engine/Shaders/lib/Light_Def.hmat unknown file type
[Error][0:0:1:897]Engine/Shaders/lib/Light_Def.hmat Light_Def load failed
[Warn][0:0:1:897]Engine/Shaders/lib/MeshData_Def.hmat unknown file type
[Error][0:0:1:897]Engine/Shaders/lib/MeshData_Def.hmat MeshData_Def load failed
[Warn][0:0:1:897]Engine/Shaders/lib/MorphData_Def.hmat unknown file type
[Error][0:0:1:897]Engine/Shaders/lib/MorphData_Def.hmat MorphData_Def load failed
[Warn][0:0:1:898]Engine/Shaders/lib/ParticleData_Def.hmat unknown file type
[Error][0:0:1:898]Engine/Shaders/lib/ParticleData_Def.hmat ParticleData_Def load failed
[Warn][0:0:1:898]Engine/Shaders/lib/PBR_Lib.hmat unknown file type
[Error][0:0:1:898]Engine/Shaders/lib/PBR_Lib.hmat PBR_Lib load failed
[Warn][0:0:1:899]Engine/Shaders/lib/SkeletonMeshData_Def.hmat unknown file type
[Error][0:0:1:899]Engine/Shaders/lib/SkeletonMeshData_Def.hmat SkeletonMeshData_Def load failed
[Warn][0:0:1:899]Engine/Shaders/lib/Toon_Lib.hmat unknown file type
[Error][0:0:1:899]Engine/Shaders/lib/Toon_Lib.hmat Toon_Lib load failed
[Warn][0:0:1:899]Engine/Shaders/lib/TransformData_Def.hmat unknown file type
[Error][0:0:1:900]Engine/Shaders/lib/TransformData_Def.hmat TransformData_Def load failed
[Log][0:0:1:901]Engine/Shaders/Outline.mat load
[Log][0:0:1:902]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
uniform sampler2D colorMap;
uniform sampler2D noiseMap;
in Particle particle;
in vec2 UV;
layout (location = 0) out vec4 FragColor;
void main()
{
    FragColor = particle.color * texture(colorMap, UV);
    FragColor.a = FragColor.a * texture(noiseMap, UV).r;
}

[Error][0:0:1:902]Particle.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:902]Engine/Shaders/Particle.mat load
[Log][0:0:1:905]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
layout (std430, binding = PARTICLE_BIND_INDEX) buffer ParticleBuffer
{
    Particle Particles[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
out Particle particle;
void main()
{
    particle = Particles[gl_InstanceID + gl_BaseInstance];
    gl_Position = camData.pmat * vec4(particle.pos, 1.0);
    gl_PointSize = particle.scale.x;
}

[Error][0:0:1:905]Particle_p.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle_p.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle_p.mat(13,5-8): error X3000: unrecognized identifier 'vec3'

[Log][0:0:1:906]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
struct Particle
{
    vec3 pos;
    float lifetime;
    vec3 scale;
    float maxLifetime;
    vec3 velocity;
    float type;
    vec3 acceleration;
    float extSca;
    vec4 extVec;
    vec4 color;
};
uniform sampler2D colorMap;
in Particle particle;
in vec2 UV;
layout (location = 0) out vec4 FragColor;
void main()
{
    FragColor = particle.color;// * texture(colorMap, UV);
}

[Error][0:0:1:906]Particle_p.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle_p.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Particle_p.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:907]Engine/Shaders/Particle_p.mat load
[Log][0:0:1:908]Engine/Shaders/PBR.mat load
[Log][0:0:1:909]Engine/Shaders/PBR_Alpha.mat load
[Log][0:0:1:920]Fragment Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D depthMap;
const mat4 thresholdMatrix = mat4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
void main() {
    vec4 _cm = texture(colorMap, TexCoords);
    vec3 albedo = baseColor.rgb * _cm.rgb;
    float alpha = baseColor.a * _cm.a;
   
    ivec2 pos = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y));
    if (alpha < thresholdMatrix[(pos.x % 4)][(pos.y % 4)])
        discard;
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    vec3 ambient = PBR_Ambient(albedo, _ao);
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    
    FragColor = vec4(color, alpha);
}

[Error][0:0:1:920]PBR_Dither.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Dither.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Dither.mat(13,5-8): error X3000: unrecognized identifier 'vec3'

[Log][0:0:1:920]Engine/Shaders/PBR_Dither.mat load
[Log][0:0:1:926]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
out vec3 WorldPos;
out vec3 WorldScale;
out vec3 Normal;
out vec3 LocalNormal;
out vec2 TexCoords;
out vec4 lightSpacePos;
vec3 getScale(mat4 tmat)
{
    vec3 scale;
    scale[0] = length(vec3(tmat[0][0], tmat[1][0], tmat[2][0]));
    scale[1] = length(vec3(tmat[0][1], tmat[1][1], tmat[2][1]));
    scale[2] = length(vec3(tmat[0][2], tmat[1][2], tmat[2][2]));
    return scale;
}
void main()
{
   mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
   WorldPos = (fm * vec4(pos.x, pos.y, pos.z, 1.0)).xyz;
   gl_Position = camData.pmat * vec4(WorldPos, 1.0);
   lightSpacePos = directLight.lmat * vec4(WorldPos, 1.0);
   TexCoords = uv;
   TexCoords.y = 1 - TexCoords.y;
   Normal = normalize(mat3(fm) * norm);
   LocalNormal = norm;
   WorldScale = getScale(fm);
}

[Error][0:0:1:926]PBR_Grid.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:931]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
out vec3 WorldPos;
out vec3 WorldScale;
out vec3 Normal;
out vec3 LocalNormal;
out vec2 TexCoords;
out vec4 lightSpacePos;
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
vec3 getScale(mat4 tmat)
{
    vec3 scale;
    scale[0] = length(vec3(tmat[0][0], tmat[1][0], tmat[2][0]));
    scale[1] = length(vec3(tmat[0][1], tmat[1][1], tmat[2][1]));
    scale[2] = length(vec3(tmat[0][2], tmat[1][2], tmat[2][2]));
    return scale;
}
void main()
{
   mat4 fm = getFinalMat();
   WorldPos = (fm * vec4(pos.x, pos.y, pos.z, 1.0)).xyz;
   gl_Position = camData.pmat * vec4(WorldPos, 1.0);
   lightSpacePos = directLight.lmat * vec4(WorldPos, 1.0);
   TexCoords = uv;
   TexCoords.y = 1 - TexCoords.y;
   Normal = normalize(mat3(fm) * norm);
   LocalNormal = norm;
   WorldScale = getScale(fm);
}

[Error][0:0:1:931]PBR_Grid.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:936]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
layout (std430, binding = MORPHDATA_BIND_INDEX) buffer CB1
{
    vec4 nMorphV;
    vec4 morphData[];
};
layout (std430, binding = MORPHWEIGHT_BIND_INDEX) buffer CB2
{
    float morphWeight[];
};
out vec3 WorldPos;
out vec3 WorldScale;
out vec3 Normal;
out vec3 LocalNormal;
out vec2 TexCoords;
out vec4 lightSpacePos;
vec3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}
vec3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
vec3 getScale(mat4 tmat)
{
    vec3 scale;
    scale[0] = length(vec3(tmat[0][0], tmat[1][0], tmat[2][0]));
    scale[1] = length(vec3(tmat[0][1], tmat[1][1], tmat[2][1]));
    scale[2] = length(vec3(tmat[0][2], tmat[1][2], tmat[2][2]));
    return scale;
}
void main()
{
   mat4 fm = getFinalMat();
   WorldPos = (fm * vec4(morphPos(), 1.0)).xyz;
   gl_Position = camData.pmat * vec4(WorldPos, 1.0);
   lightSpacePos = directLight.lmat * vec4(WorldPos, 1.0);
   TexCoords = uv;
   TexCoords.y = 1 - TexCoords.y;
   LocalNormal = morphNorm();
   Normal = normalize(mat3(fm) * LocalNormal);
   WorldScale = getScale(fm);
}

[Error][0:0:1:937]PBR_Grid.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:946]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 WorldScale;
in vec3 Normal;
in vec3 LocalNormal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform vec4 chessColor;
uniform vec4 lineColor;
uniform vec4 pointColor;
uniform vec4 gridOffset;
uniform float gridSpace;
uniform float patternX;
uniform float patternY;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
vec2 getUVScale(vec3 scale, vec3 N)
{
    vec3 a = round(normalize(pow(abs(N), vec3(8.0))));
    vec2 yz = vec2(scale.y, scale.z);
    vec2 xz = vec2(scale.x, scale.z);
    vec2 xy = vec2(scale.x, scale.y);
    return mix(mix(yz, xy, a.z), xz, a.y);
}
vec4 getUVs(vec2 UV)
{
    vec4 re;
    UV += gridOffset.xy;
    re.xy = UV * 50.0 / (patternX + patternY);
    re.zw = UV * 100.0 / gridSpace;
    return re;
}
vec4 getGirdInfo(sampler2D tex, vec4 UVs)
{
    vec4 info;
    vec4 bc = texture(tex, UVs.xy);
    vec4 sc = texture(tex, UVs.zw);
    info.r = bc.b;
    info.g = bc.r + sc.g;
    info.b = bc.r;
    info.a = bc.b * bc.a;
    return info;
}
void main() {
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale);
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 info = getGirdInfo(colorMap, getUVs(TexCoords * getUVScale(WorldScale, LocalNormal)));
    vec4 colorMul = baseColor;
    colorMul = mix(colorMul, chessColor, info.r);
    colorMul = mix(colorMul, lineColor, info.g);
    vec3 albedo = colorMul.rgb;
    float alpha = colorMul.a;
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    vec3 ambient = PBR_Ambient(albedo, _ao);
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    FragColor = vec4(color, alpha);
}

[Error][0:0:1:947]PBR_Grid.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:947]Engine/Shaders/PBR_Grid.mat load
[Log][0:0:1:959]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 LocalPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform vec4 chessColor;
uniform vec4 lineColor;
uniform vec4 pointColor;
uniform vec4 gridOffset;
uniform float chessSpace;
uniform float lineSpace;
uniform float lineWidth;
uniform float pointSpace;
uniform float pointWidth;
uniform float UseLocalSpace;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
float getChess(vec3 pos, float space, vec3 N)
{
    vec3 modfp = mod(pos, space);
    for (int i = 0; i < 3; i++) {
        if (abs(N[i]) > 0.999) {
            pos[i] -= N[i] * 0.001;
        }
    }
    vec3 modp = mod(pos, space * 2);
    return modp.x < space ^^ modp.y < space ^^ modp.z < space ? 0 : 1;
}
vec3 getLine3(vec3 pos, float space, float width, vec3 N)
{
    vec3 modp = mod(abs(pos), space) - vec3(space / 2);
    vec3 amodp;
    for (int i = 0; i < 3; i++) {
        vec3 axis = vec3(0);
        axis[i] = 1;
        float dt = 1 - abs(dot(N, axis));
        if (dt <= 0.0001)
            amodp[i] = 0;
        else {
            amodp[i] = smoothstep(0, width, abs(modp[i]) - space / 2 + width);
        }
    }
    return amodp;
}
float getLine(vec3 pos, float space, float width, vec3 N)
{
    float originalZ = gl_FragCoord.z / gl_FragCoord.w;
    float dm = max(0, (1 - originalZ / 1000));
    if (dm == 0)
        return 0;
    vec3 line = getLine3(pos, space, width, N);
    float v = line.x + line.y + line.z;
    return max(max(line.x, line.y), line.z) * dm;
}
float getPoint(vec3 pos, float space, float width, vec3 N)
{
    vec3 line = getLine3(pos, space, width, N);
    float v = line.x + line.y + line.z;
    return v >= 1 ? 1 : 0;
}
void main() {
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 colorMul = baseColor;
    vec3 gridPos = (UseLocalSpace == 0 ? WorldPos : LocalPos) + gridOffset.xyz;
    colorMul = mix(colorMul, chessColor, getChess(gridPos, chessSpace, N));
    colorMul = mix(colorMul, lineColor, getLine(gridPos, lineSpace, lineWidth, N));
    colorMul = mix(colorMul, pointColor, getPoint(gridPos, pointSpace, pointWidth, N));
    vec4 colorMapValue = texture(colorMap, TexCoords);
    vec3 albedo = colorMul.rgb * colorMapValue.rgb;
    float alpha = colorMul.a * colorMapValue.a;
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    vec3 ambient = PBR_Ambient(albedo, _ao);
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    FragColor = vec4(color, alpha);
}

[Error][0:0:1:959]PBR_Grid_Programmed.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid_Programmed.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_Grid_Programmed.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:959]Engine/Shaders/PBR_Grid_Programmed.mat load
[Log][0:0:1:961]Engine/Shaders/PBR_IBL.mat load
[Log][0:0:1:963]Engine/Shaders/PBR_IBL_Alpha.mat load
[Log][0:0:1:974]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform vec4 reflectionColor;
uniform sampler2D reflectionMap;
uniform sampler2D irradianceMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D brdfLUT;
uniform sampler2D depthMap;
const mat4 thresholdMatrix = mat4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
void main() {
    vec4 _cm = texture(colorMap, TexCoords);
    vec3 albedo = baseColor.rgb * _cm.rgb;
    float alpha = baseColor.a * _cm.a;
    ivec2 pos = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y));
    if (alpha < thresholdMatrix[(pos.x % 4)][(pos.y % 4)])
        discard;
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    // IBL
    vec3 L = normalize(-reflect(-V, N));
    vec3 H = normalize(L + V);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0, _roughness);
    vec3 kD = 1.0 - F;
    kD *= 1.0 - metallic;
    vec2 coord = sphereProj(-L);
    coord.y = 1 - coord.y;
    vec3 rel = textureLod(reflectionMap, coord, roughness * (textureQueryLevels(reflectionMap) - 1)).xyz;
    vec3 irrad = texture(irradianceMap, coord).xyz;
    coord = vec2(max(dot(N, V), 0.0), roughness);
    coord.y = 1 - coord.y;
    vec2 envBRDF = texture(brdfLUT, coord).rg;
    vec3 Le = rel * (F * envBRDF.x + envBRDF.y);
    vec3 iblAmbient = kD * irrad * albedo + Le;
    vec3 pbrAmbient = vec3(0.03) * albedo;
    // Combination
    vec3 ambient = mix(pbrAmbient, iblAmbient, reflectionColor.xyz) * _ao;
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    FragColor = vec4(color, alpha);
}

[Error][0:0:1:974]PBR_IBL_Dither.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Dither.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Dither.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:975]Engine/Shaders/PBR_IBL_Dither.mat load
[Log][0:0:1:987]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 TexCoords;
in vec3 WorldPos;
in vec3 LocalPos;
in vec3 Normal;
in vec4 lightSpacePos;
uniform vec4 baseColor;
uniform vec4 chessColor;
uniform vec4 lineColor;
uniform vec4 pointColor;
uniform vec4 gridOffset;
uniform float chessSpace;
uniform float lineSpace;
uniform float lineWidth;
uniform float pointSpace;
uniform float pointWidth;
uniform float UseLocalSpace;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform vec4 reflectionColor;
uniform sampler2D reflectionMap;
uniform sampler2D irradianceMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D brdfLUT;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2 = a*a;
    a2 *= a2;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return nom / denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}
vec3 PBR_Lo(vec3 N, vec3 V, vec3 L, vec3 radiance, vec3 albedo, float metallic, float roughness)
{
    vec3 H = normalize(V + L);
    
    // cook-torrance brdf
    float NDF = D_GGX_TR(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    vec3 nominator = NDF * G * F;
    float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; 
    vec3 specular = nominator / denominator;
    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}
vec3 PBR_Lo_DirectLight(DirectLight directLight, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(directLight.direction);
    vec3 radiance = directLight.color * directLight.intensity;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Lo_PointLight(PointLight pointLight, vec3 worldPos, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(pointLight.pos - worldPos);
    float distance = length(pointLight.pos - worldPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = pointLight.color * pointLight.intensity * attenuation;
    return PBR_Lo(N, V, L, radiance, albedo, metallic, roughness);
}
vec3 PBR_Ambient(vec3 albedo, float ao)
{
    return vec3(0.03) * albedo * ao;
}
float getChess(vec3 pos, float space)
{
    vec3 modp = mod(pos, space * 2);
    return modp.x < space ^^ modp.y < space ^^ modp.z < space ? 0 : 1;
}
vec3 getLine3(vec3 pos, float space, float width, vec3 N)
{
    vec3 modp = mod(abs(pos), space) - vec3(space / 2);
    vec3 amodp = smoothstep(0, width * 0.3, abs(modp) - vec3(space / 2 - width));
    if (amodp.x != 0)
        if ((1 - abs(dot(N, vec3(1, 0, 0)))) <= 0.0001)
            amodp.x = 0;
    if (amodp.y != 0)
        if ((1 - abs(dot(N, vec3(0, 1, 0)))) <= 0.0001)
            amodp.y = 0;
    if (amodp.z != 0)
        if ((1 - abs(dot(N, vec3(0, 0, 1)))) <= 0.0001)
            amodp.z = 0;
    return amodp;
}
float getLine(vec3 pos, float space, float width, vec3 N)
{
    vec3 line = getLine3(pos, space, width, N);
    float v = line.x + line.y + line.z;
    return max(max(line.x, line.y), line.z);
}
float getPoint(vec3 pos, float space, float width, vec3 N)
{
    vec3 line = getLine3(pos, space, width, N);
    float v = line.x + line.y + line.z;
    return v >= 2 ? 1 : 0;
}
void main() {
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 colorMul = baseColor;
    vec3 gridPos = (UseLocalSpace == 0 ? WorldPos : LocalPos) + gridOffset.xyz;
    colorMul = mix(colorMul, chessColor, getChess(gridPos, chessSpace));
    colorMul = mix(colorMul, lineColor, getLine(gridPos, lineSpace, lineWidth, N));
    colorMul = mix(colorMul, pointColor, getPoint(gridPos, pointSpace, pointWidth, N));
    vec4 colorMapValue = texture(colorMap, TexCoords);
    vec3 albedo = colorMul.rgb * colorMapValue.rgb;
    float alpha = colorMul.a * colorMapValue.a;
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, _metallic);
    // reflectance equation
    vec3 Lo = vec3(0.0);
    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }
    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }
    // IBL
    vec3 L = normalize(-reflect(-V, N));
    vec3 H = normalize(L + V);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0, _roughness);
    vec3 kD = 1.0 - F;
    kD *= 1.0 - metallic;
    vec2 coord = sphereProj(-L);
    coord.y = 1 - coord.y;
    vec3 rel = textureLod(reflectionMap, coord, roughness * (textureQueryLevels(reflectionMap) - 1)).xyz;
    vec3 irrad = texture(irradianceMap, coord).xyz;
    coord = vec2(max(dot(N, V), 0.0), roughness);
    coord.y = 1 - coord.y;
    vec2 envBRDF = texture(brdfLUT, coord).rg;
    vec3 Le = rel * (F * envBRDF.x + envBRDF.y);
    vec3 iblAmbient = kD * irrad * albedo + Le;
    vec3 pbrAmbient = vec3(0.03) * albedo;
    // Combination
    vec3 ambient = mix(pbrAmbient, iblAmbient, reflectionColor.xyz) * _ao;
    vec3 emissionColor = texture(emissionMap, TexCoords).rgb;
    vec3 color = ambient + Lo;//vec3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2)) + (emission * emissionColor).rgb;
    FragColor = vec4(color, alpha);
}

[Error][0:0:1:987]PBR_IBL_Grid.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Grid.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_Grid.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:988]Engine/Shaders/PBR_IBL_Grid.mat load
[Log][0:0:1:989]Engine/Shaders/PBR_IBL_Transparent.mat load
[Log][0:0:1:995]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
uniform vec4 UVScale;
out vec3 WorldPos;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
void main()
{
    mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    vec4 _WorldPos = fm * vec4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}

[Error][0:0:1:995]PBR_IBL_UV.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:1:999]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
uniform vec4 UVScale;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    vec4 _WorldPos = fm * vec4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}

[Error][0:0:2:0]PBR_IBL_UV.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:5]Vertex Shader
#version 460 core
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
layout (location = 3) in uvec4 boneId;
layout (location = 4) in vec4 weights;
layout (std430, binding = MORPHDATA_BIND_INDEX) buffer CB1
{
    vec4 nMorphV;
    vec4 morphData[];
};
layout (std430, binding = MORPHWEIGHT_BIND_INDEX) buffer CB2
{
    float morphWeight[];
};
uniform vec4 UVScale;
out vec3 Normal;
out vec2 TexCoords;
out vec4 lightSpacePos;
out vec3 WorldPos;
vec3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}
vec3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    vec3 w = vec3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}
mat4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    mat4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}
void main()
{
    mat4 fm = getFinalMat();
    vec4 _WorldPos = fm * vec4(morphPos(), 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(mat3(fm) * morphNorm());
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}

[Error][0:0:2:5]PBR_IBL_UV.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PBR_IBL_UV.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:5]Engine/Shaders/PBR_IBL_UV.mat load
[Log][0:0:2:7]Engine/Shaders/PBR_Transparent.mat load
[Log][0:0:2:7]Engine/Shaders/PostProcess folder
[Log][0:0:2:8]Vertex Shader
#version 460 core
const vec2 quadVertices[4] = vec2[](vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0));
const vec2 quadUV[4] = vec2[](vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0));
out vec2 UV;
void main()
{
    gl_Position = vec4(quadVertices[gl_VertexID], 0.0, 1.0);
    UV = quadUV[gl_VertexID];
}

[Error][0:0:2:8]BlitPass.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlitPass.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlitPass.mat(2,7-10): error X3000: unrecognized identifier 'vec2'

[Log][0:0:2:9]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
uniform sampler2D screenMap;
layout (location = 0) out vec4 FragColor;
in vec2 UV;
void main() {
    FragColor = textureLod(screenMap, UV, 0);
}

[Error][0:0:2:9]BlitPass.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlitPass.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BlitPass.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:9]Engine/Shaders/PostProcess/BlitPass.mat load
[Log][0:0:2:12]Compute Shader
#version 460
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
uniform int pass;
uniform int bloomLevel;
uniform int bloomIter;
uniform float gamma;
uniform float exposure;
uniform float bloomLightIntensity;
uniform float bloomDarkIntensity;
uniform float bloomThreshold;
uniform sampler2D sampleMap;
layout(rgba8, binding = 0) uniform image2D imageMap;
layout(local_size_x = LOCAL_SIZE_2D, local_size_y = LOCAL_SIZE_2D) in;
// const int maxIter = MAX_SHARED_SIZE_2D - LOCAL_SIZE_2D / 2;
// shared float samples[MAX_SHARED_SIZE_2D][MAX_SHARED_SIZE_2D];
// void loadSharedData() {
//     int length = bloomIter * 2 + LOCAL_SIZE_2D;
// }
void syncronize()
{
	memoryBarrier();
	barrier();
}
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(imageMap);
	if (pos.x < size.x && pos.y < size.y) {
		vec4 pixel = vec4(0.0);
		float coef = 0.0;
        if (pass == 0) {
	        vec2 uv = vec2(pos.x / float(size.x), pos.y / float(size.y));
            pixel = texture(sampleMap, uv);
			vec3 col = pixel.rgb;
            vec3 rate = smoothstep(bloomThreshold, bloomThreshold + 0.1, col) * col - vec3(bloomThreshold);
            col = mix(bloomDarkIntensity * col, bloomLightIntensity * col, rate);
			col = vec3(1.0) - exp(-col * exposure);
        	col = pow(col, vec3(1.0/gamma));
			pixel.rgb = col;
            imageStore(imageMap, pos, pixel);
        }
		if (pass == 1) {
			for (int dx = -bloomIter; dx <= bloomIter; dx++) {
				int x = pos.x + dx;
				if (x < 0 || x >= size.x) {
					continue;
				}
				float c = 1 - abs(dx) / float(bloomIter);
				c = c * c;
				pixel += imageLoad(imageMap, ivec2(x, pos.y)) * c;
				coef += c;
			}
            syncronize();
			imageStore(imageMap, pos, pixel / coef);
		}
		else if (pass == 2) {
			for (int dy = -bloomIter; dy <= bloomIter; dy++) {
				int y = pos.y + dy;
				if (y < 0 || y >= size.y) {
					continue;
				}
				float c = 1 - abs(dy) / float(bloomIter);
				c = c * c;
				pixel += imageLoad(imageMap, ivec2(pos.x, y)) * c;
				coef += c;
			}
            syncronize();
			imageStore(imageMap, pos, pixel / coef);
		}
        else if (pass == 3) {
	        vec2 uv = vec2(pos.x / float(size.x), pos.y / float(size.y));
            pixel = imageLoad(imageMap, pos);
            for (int i = 0; i < bloomLevel; i++) {
                pixel += textureLod(sampleMap, uv, i) * (1 - i * 0.1);
            }
            syncronize();
			imageStore(imageMap, pos, pixel);
        }
	}
}

[Error][0:0:2:13]BloomPassCS.mat (Compute Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BloomPassCS.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BloomPassCS.mat(6,13-30): warning X3207: Initializer used on a global 'const' variable. This requires setting an external constant. If a literal is desired, use 'static const' instead.
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BloomPassCS.mat(7,13-16): error X3000: syntax error: unexpected token 'pass'

[Log][0:0:2:13]Engine/Shaders/PostProcess/BloomPassCS.mat load
[Log][0:0:2:15]Fragment Shader
#version 460
layout(early_fragment_tests) in;
layout (location = 0) out vec4 FragColor;
in vec2 UV;
uniform int pass;
uniform int bloomLevel;
uniform int bloomIter;
uniform float width;
uniform float height;
uniform float gamma;
uniform float exposure;
uniform float bloomLightIntensity;
uniform float bloomDarkIntensity;
uniform float bloomThreshold;
uniform sampler2D sampleMap;
uniform sampler2D screenMap;
void main() {
	vec4 pixel = vec4(0.0);
    if (pass == 0) {
        pixel = texture(sampleMap, UV);
		vec3 col = pixel.rgb;
        vec3 rate = smoothstep(bloomThreshold, bloomThreshold + 0.1, col) * col - vec3(bloomThreshold);
        col = mix(bloomDarkIntensity * col, bloomLightIntensity * col, rate);
		col = vec3(1.0) - exp(-col * exposure);
        col = pow(col, vec3(1.0/gamma));
		pixel.rgb = col;
        FragColor = pixel;
    }
	else if (pass == 1) {
		float bloomOffset = (-0.02 * bloomIter + 0.6) / width;
		for (int dx = -bloomIter; dx <= bloomIter; dx++) {
			pixel += texture(sampleMap, UV + vec2(bloomOffset * dx, 0));
		}
        FragColor = pixel / (bloomIter * 2 - 1);
	}
	else if (pass == 2) {
		float bloomOffset = (-0.02 * bloomIter + 0.6) / height;
		for (int dy = -bloomIter; dy <= bloomIter; dy++) {
			pixel += texture(sampleMap, UV + vec2(0, bloomOffset * dy));
		}
        FragColor = pixel / (bloomIter * 2 - 1);
	}
    else if (pass == 3) {
        pixel = texture(screenMap, UV);
        for (int i = 0; i < bloomLevel; i++) {
            pixel += textureLod(sampleMap, UV, i) * (1 - i * 0.1);
        }
		pixel.a = 1.0;
        FragColor = pixel;
    }
}

[Error][0:0:2:15]BloomPassFS.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BloomPassFS.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\BloomPassFS.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:15]Engine/Shaders/PostProcess/BloomPassFS.mat load
[Log][0:0:2:20]Fragment Shader
#version 460
layout(early_fragment_tests) in;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 UV;
uniform int pass;
uniform float blurRadius;
uniform float blurIter;
uniform float blurNear;
uniform float blurFar;
uniform float blurSmoothNear;
uniform float blurSmoothFar;
uniform float blurNearIntensity;
uniform float blurFarIntensity;
uniform sampler2D dofMap;
uniform sampler2D screenMap;
uniform sampler2D depthMap;
const uint dofKernelN = 57;
const vec2 dofKernel[57] = vec2[](
    vec2(0.000000, 0.000000),
    vec2(0.461940, 0.191342), vec2(0.191342, 0.461940), vec2(-0.191342, 0.461940), vec2(-0.461940, 0.191342),
    vec2(-0.461940, -0.191342), vec2(-0.191342, -0.461940), vec2(0.191342, -0.461940), vec2(0.461940, -0.191342),
    vec2(1.000000, 0.000000), vec2(0.923880, 0.382683), vec2(0.707107, 0.707107), vec2(0.382683, 0.923880),
    vec2(0.000000, 1.000000), vec2(-0.382683, 0.923880), vec2(-0.707107, 0.707107), vec2(-0.923880, 0.382683),
    vec2(-1.000000, 0.000000), vec2(-0.923880, -0.382683), vec2(-0.707107, -0.707107), vec2(-0.382683, -0.923880),
    vec2(-0.000000, -1.000000), vec2(0.382683, -0.923880), vec2(0.707107, -0.707107), vec2(0.923880, -0.382683),
    vec2(1.492777, 0.147026), vec2(1.435411, 0.435427), vec2(1.322882, 0.707095), vec2(1.159516, 0.951590),
    vec2(0.951590, 1.159516), vec2(0.707095, 1.322882), vec2(0.435427, 1.435411), vec2(0.147026, 1.492777),
    vec2(-0.147026, 1.492777), vec2(-0.435427, 1.435411), vec2(-0.707095, 1.322882), vec2(-0.951590, 1.159516),
    vec2(-1.159516, 0.951590), vec2(-1.322882, 0.707095), vec2(-1.435411, 0.435427), vec2(-1.492777, 0.147026),
    vec2(-1.492777, -0.147026), vec2(-1.435411, -0.435427), vec2(-1.322882, -0.707095), vec2(-1.159516, -0.951590),
    vec2(-0.951590, -1.159516), vec2(-0.707095, -1.322882), vec2(-0.435427, -1.435411), vec2(-0.147026, -1.492777),
    vec2(0.147026, -1.492777), vec2(0.435427, -1.435411), vec2(0.707095, -1.322882), vec2(0.951590, -1.159516),
    vec2(1.159516, -0.951590), vec2(1.322882, -0.707095), vec2(1.435411, -0.435427), vec2(1.492777, -0.147026)
);
void main() {
	if (pass == 0) {
        float weight = 0;
        vec3 c = vec3(0);
        int n = blurIter < 1 ? 1 : (blurIter < 2 ? 9 : (blurIter < 3 ? 25 : 57));
        for (int i = 0; i < n; i++) {
            vec2 off = dofKernel[i] * blurRadius;
            off /= camData.viewSize;
            float linearDepth = 2.0 * camData.zNear * camData.zFar / (camData.zFar + camData.zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (camData.zFar - camData.zNear));
            float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) +
                smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth);
            if (rate != 0) {
                vec3 cc = texture(screenMap, UV + off * rate).rgb;
                float w = length(cc) + 0.1;
                weight += w;
                c += cc * w;
            }
        }
        FragColor.rgb = c / weight;//((1 + n) * n);
        FragColor.a = 1.0;
    }
    else if (pass == 1) {
        float linearDepth = 2.0 * camData.zNear * camData.zFar / (camData.zFar + camData.zNear - (2.0 * texture(depthMap, UV).r - 1.0) * (camData.zFar - camData.zNear));
        vec4 blurC = texture(dofMap, UV);
        vec4 screenC = texture(screenMap, UV);
        float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) * blurNearIntensity +
            smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth) * blurFarIntensity;
        FragColor = mix(screenC, blurC, rate);
    }
}

[Error][0:0:2:21]DOFPassFS.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\DOFPassFS.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\DOFPassFS.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:21]Engine/Shaders/PostProcess/DOFPassFS.mat load
[Log][0:0:2:26]Fragment Shader
#version 460
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
in vec2 UV;
uniform int pass;
uniform float ssaoRadius;
uniform float ssaoIntensity;
uniform float ssaoArea;
uniform float ssaoFalloff;
uniform float ssaoCutoff;
uniform float ssaobias;
uniform int ssaoBlurIter;
uniform float screenScale;
uniform sampler2D ssaoMap;
uniform sampler2D ssaoKernalMap;
uniform sampler2D depthMap;
const vec3 sample_sphere[16] = vec3[](
    vec3( 0.5381, 0.1856,-0.4319), vec3( 0.1379, 0.2486, 0.4430),
    vec3( 0.3371, 0.5679,-0.0057), vec3(-0.6999,-0.0451,-0.0019),
    vec3( 0.0689,-0.1598,-0.8547), vec3( 0.0560, 0.0069,-0.1843),
    vec3(-0.0146, 0.1402, 0.0762), vec3( 0.0100,-0.1924,-0.0344),
    vec3(-0.3577,-0.5301,-0.4358), vec3(-0.3169, 0.1063, 0.0158),
    vec3( 0.0103,-0.5869, 0.0046), vec3(-0.0897,-0.4940, 0.3287),
    vec3( 0.7119,-0.0154,-0.0918), vec3(-0.0533, 0.0596,-0.5411),
    vec3( 0.0352,-0.0631, 0.5460), vec3(-0.4776, 0.2847,-0.0271)
);
vec3 normalFromDepth(float depth, vec2 texcoords) 
{
	vec2 offset1 = vec2(0.0,0.0001);
	vec2 offset2 = vec2(0.0001,0.0);
	vec2 offset3 = vec2(0.0,-0.0001);
	vec2 offset4 = vec2(-0.0001,0.0);
	float depth1 = texture2D(depthMap, texcoords + offset1).r;
	float depth2 = texture2D(depthMap, texcoords + offset2).r;
	float depth3 = texture2D(depthMap, texcoords + offset3).r;
	float depth4 = texture2D(depthMap, texcoords + offset4).r;
	vec3 p1 = vec3(offset1, depth1 - depth);
	vec3 p2 = vec3(offset2, depth2 - depth);
	vec3 p3 = vec3(offset3, depth3 - depth);
	vec3 p4 = vec3(offset4, depth4 - depth);
	vec3 normal1 = cross(p1, p2);
	vec3 normal2 = cross(p2, p3);
	vec3 normal3 = cross(p3, p4);
	vec3 normal4 = cross(p4, p1);
	vec3 normal = (normal1 + normal2 + normal3 + normal4) / 4;
	normal.z = -normal.z;
	return normalize(normal);
}
vec3 reflection(vec3 v1,vec3 v2)
{
    vec3 result= 2.0 * dot(v2, v1) * v2;
    result=v1-result;
    return result;
}
void main() {
	float width = floor(camData.viewSize.x * screenScale);
	float height = floor(camData.viewSize.y * screenScale);
    if (pass == 0) {
        // vec3 pos = reconstructPos();
        // float AO = 0.0;
        // for (int i = 0 ; i < 16 ; i++) {
        //     vec3 samplePos = pos + ssaoKernal[i];
        //     vec4 offset = vec4(samplePos, 1.0);
        //     offset = camData.pmat * offset;
        //     offset.xy /= offset.w;
        //     offset.xy = offset.xy * 0.5 + 0.5;
        //     float sampleDepth = calViewZ(offset.xy);
        //     // float rangeCheck = smoothstep(0.0, 1.0, ssaoRadius / abs(pos.z - sampleDepth));
        //     // AO += (sampleDepth >= samplePos.z ? 1.0 : 0.0) * rangeCheck;
        //     if (abs(pos.z - sampleDepth) < ssaoRadius) {
        //         AO += step(sampleDepth,samplePos.z);
        //     }
        // }
        // AO = 1.0 - AO / 16.0;
        // oCol0.rgb = vec3(AO * AO);
        // oCol0.a = 1.0;
        float depth = texture2D(depthMap, UV).r;
        vec3 normal = normalFromDepth(depth, UV);
        if (depth < ssaoCutoff && abs(dot(normal, vec3(0, 0, 1))) < (1 - ssaobias)) {
            vec3 random = normalize(texture2D(ssaoKernalMap, UV * 8.0).rgb);
            vec3 position = vec3(UV.x,UV.y,depth);
            float radiusDepth = ssaoRadius/depth;
            float occlusion = 0.0;
            //float bias = max(ssaobias * dot(normal, vec3(0, 0, 1)), ssaobias * 0.1);
            int iterations = 16;
            for (int j = 0; j < iterations; ++j)
            {
                vec3 ray = radiusDepth * reflection(sample_sphere[j], random);
                if (dot(ray,normal) > 0) {
                    vec3 hemiRay = position + ray;
                
                    float occDepth = texture2D(depthMap, clamp(hemiRay.xy,0.0,1.0)).r;
                    float difference = depth - occDepth;
                    occlusion += smoothstep(ssaoFalloff, ssaoArea, (depth >= occDepth ? 1.0 : 0.0) * (1 - smoothstep(0, 1, abs(difference) / ssaoRadius)));
                }
                //occlusion += step(ssaoFalloff, difference) * smoothstep(ssaoFalloff, ssaoArea, difference);
            }
            float ao = occlusion * (1.0 / iterations);
            ao = smoothstep(ssaoFalloff, ssaoArea, ao) * ssaoIntensity * ao;
            ao = 1 - ao;
            float final = clamp(ao * ao,0.0,1.0);
            FragColor = vec4(final,final,final,1);
        }
        else
            FragColor = vec4(1);
    }
    else if (pass == 1) {
        vec4 c = vec4(0);
        int n = clamp(ssaoBlurIter, 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - vec2(0, ssaoOffset / height * i));
            c += texture(ssaoMap, UV + vec2(0, ssaoOffset / height * i));
        }
        FragColor = c / (n * 2.0);
        FragColor.a = 1.0;
    }
    else if (pass == 2) {
        vec4 c = vec4(0);
        int n = clamp(ssaoBlurIter, 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - vec2(ssaoOffset / width * i, 0));
            c += texture(ssaoMap, UV + vec2(ssaoOffset / width * i, 0));
        }
        FragColor = c / (n * 2.0);
        FragColor.a = 1.0;
    }
}

[Error][0:0:2:27]SSAOPassFS.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\SSAOPassFS.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\SSAOPassFS.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:27]Engine/Shaders/PostProcess/SSAOPassFS.mat load
[Log][0:0:2:30]Compute Shader
#version 460
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
uniform float gamma;
uniform float exposure;
uniform vec4 baseColor;
uniform float vignetteRate;
uniform float vignettePower;
uniform vec4 vignetteColor;
uniform float lutBlend;
uniform sampler2D ssaoMap;
uniform sampler2D lutMap;
layout(rgba8, binding = 0) uniform image2D imageMap;
layout(local_size_x = LOCAL_SIZE_2D, local_size_y = LOCAL_SIZE_2D) in;
void syncronize()
{
	memoryBarrier();
	barrier();
}
vec4 lookupTable(vec4 color, sampler2D LUT) {
    float blueColor = color.b * 63.0;
    vec2 quad1;
    quad1.y = floor(floor(blueColor) / 8.0);
    quad1.x = floor(blueColor) - (quad1.y * 8.0);
    vec2 quad2;
    quad2.y = floor(ceil(blueColor) / 8.0);
    quad2.x = ceil(blueColor) - (quad2.y * 8.0);
    //ivec2 size = textureSize(LUT, 0);
    vec2 texPos1;
    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    vec2 texPos2;
    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    vec4 newColor1 = texture(LUT, texPos1);
    vec4 newColor2 = texture(LUT, texPos2);
    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));
    return vec4(newColor.rgb, color.w);
}
void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(imageMap);
	if (pos.x < size.x && pos.y < size.y) {
		vec4 c = imageLoad(imageMap, pos) * baseColor;
		vec2 uv = vec2(pos.x / float(size.x), pos.y / float(size.y));
		c = c * texture(ssaoMap, uv);
		c.rgb = vec3(1.0) - exp(-c.rgb * exposure);
		c.rgb = pow(c.rgb, vec3(1.0/gamma));
		if (vignetteRate != 0) {
			float vx = abs(pos.x - float(size.x / 2)) / float(size.x / 2);
			float vy = abs(pos.y - float(size.y / 2)) / float(size.y / 2);
			float v = (pow(vx, vignettePower) + pow(vy, vignettePower)) / 2.0;
			v -= 1 - vignetteRate;
			v = max(v, 0);
			v /= vignetteRate;
			v = pow(v, vignettePower);
			c = mix(c, vignetteColor, v);
		}
		c = mix(c, tan(lookupTable(atan(c) * (2.0 / PI), lutMap) * (PI / 2.0)), lutBlend);
        syncronize();
		imageStore(imageMap, pos, c);
	}
}

[Error][0:0:2:30]ToneMapPass.mat (Compute Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\ToneMapPass.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\ToneMapPass.mat(6,13-30): warning X3207: Initializer used on a global 'const' variable. This requires setting an external constant. If a literal is desired, use 'static const' instead.
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\ToneMapPass.mat(9,9-12): error X3000: unrecognized identifier 'vec4'

[Log][0:0:2:30]Engine/Shaders/PostProcess/ToneMapPass.mat load
[Log][0:0:2:34]Vertex Shader
#version 410 core
const vec2 quadVertices[4] = vec2[](vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0));
const vec2 quadUV[4] = vec2[](vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0));
out vec2 UV;
void main()
{
    gl_Position = vec4(quadVertices[gl_VertexID], 0.0, 1.0);
    UV = quadUV[gl_VertexID];
}

[Error][0:0:2:34]PostProcessing.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PostProcessing.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PostProcessing.mat(2,7-10): error X3000: unrecognized identifier 'vec2'

[Log][0:0:2:51]Fragment Shader
#version 410 core
layout(early_fragment_tests) in;
layout (location = 0) out vec4 oCol0;
layout (location = 1) out vec4 oCol1;
in vec2 UV;
uniform vec3 camPos;
uniform vec4 lensFlareColor;
uniform vec4 sunDir;
uniform mat4 tmat;
uniform mat4 pmat;
uniform mat4 promat;
uniform mat4 vmat;
uniform mat4 lmat;
uniform float fovy;
uniform float fovDiv;
uniform float gamma;
uniform float exposure;
uniform vec4 volumnicLightColor;
uniform float G_SCATTERING;
uniform float fogDistance;
uniform float volumnicFogStep;
uniform float volumnicFogBlurIter;
uniform float bloomLightIntensity;
uniform float bloomDarkIntensity;
uniform float bloomThreshold;
uniform float bloomIter;
uniform float blurRadius;
uniform float blurIter;
uniform float blurNear;
uniform float blurFar;
uniform float blurSmoothNear;
uniform float blurSmoothFar;
uniform float blurNearIntensity;
uniform float blurFarIntensity;
uniform float ssaoRadius;
uniform float ssaoIntensity;
uniform float ssaoArea;
uniform float ssaoFalloff;
uniform float ssaoCutoff;
uniform float ssaobias;
uniform float ssaoBlurIter;
uniform float width;
uniform float height;
uniform float zNear;
uniform float zFar;
uniform float lutBlend;
uniform float enableSNN;
uniform sampler2D depthMap;
uniform sampler2D screenMap;
uniform sampler2D volumnicFogMap;
uniform sampler2D ssaoMap;
uniform sampler2D ssaoKernalMap;
uniform sampler2D LUT;
uniform sampler2D blurMap;
uniform sampler2D bloomMap_0;
uniform sampler2D bloomMap_1;
uniform sampler2D bloomMap_2;
uniform sampler2D bloomMap_3;
uniform sampler2D bloomMap_4;
uniform sampler2D bloomMap_5;
uniform sampler2D extraMap_0;
uniform int pass;
const float PI = 3.14159265359;
const mat4 ditherPattern = mat4(
    0.0f, 0.5f, 0.125f, 0.625f,
    0.75f, 0.22f, 0.875f, 0.375f,
    0.1875f, 0.6875f, 0.0625f, 0.5625,
    0.9375f, 0.4375f, 0.8125f, 0.3125
);
const vec3 sample_sphere[16] = vec3[](
    vec3( 0.5381, 0.1856,-0.4319), vec3( 0.1379, 0.2486, 0.4430),
    vec3( 0.3371, 0.5679,-0.0057), vec3(-0.6999,-0.0451,-0.0019),
    vec3( 0.0689,-0.1598,-0.8547), vec3( 0.0560, 0.0069,-0.1843),
    vec3(-0.0146, 0.1402, 0.0762), vec3( 0.0100,-0.1924,-0.0344),
    vec3(-0.3577,-0.5301,-0.4358), vec3(-0.3169, 0.1063, 0.0158),
    vec3( 0.0103,-0.5869, 0.0046), vec3(-0.0897,-0.4940, 0.3287),
    vec3( 0.7119,-0.0154,-0.0918), vec3(-0.0533, 0.0596,-0.5411),
    vec3( 0.0352,-0.0631, 0.5460), vec3(-0.4776, 0.2847,-0.0271)
);
const uint dofKernelN = 57;
const vec2 dofKernel[57] = vec2[](
    vec2(0.000000, 0.000000),
    vec2(0.461940, 0.191342), vec2(0.191342, 0.461940), vec2(-0.191342, 0.461940), vec2(-0.461940, 0.191342),
    vec2(-0.461940, -0.191342), vec2(-0.191342, -0.461940), vec2(0.191342, -0.461940), vec2(0.461940, -0.191342),
    vec2(1.000000, 0.000000), vec2(0.923880, 0.382683), vec2(0.707107, 0.707107), vec2(0.382683, 0.923880),
    vec2(0.000000, 1.000000), vec2(-0.382683, 0.923880), vec2(-0.707107, 0.707107), vec2(-0.923880, 0.382683),
    vec2(-1.000000, 0.000000), vec2(-0.923880, -0.382683), vec2(-0.707107, -0.707107), vec2(-0.382683, -0.923880),
    vec2(-0.000000, -1.000000), vec2(0.382683, -0.923880), vec2(0.707107, -0.707107), vec2(0.923880, -0.382683),
    vec2(1.492777, 0.147026), vec2(1.435411, 0.435427), vec2(1.322882, 0.707095), vec2(1.159516, 0.951590),
    vec2(0.951590, 1.159516), vec2(0.707095, 1.322882), vec2(0.435427, 1.435411), vec2(0.147026, 1.492777),
    vec2(-0.147026, 1.492777), vec2(-0.435427, 1.435411), vec2(-0.707095, 1.322882), vec2(-0.951590, 1.159516),
    vec2(-1.159516, 0.951590), vec2(-1.322882, 0.707095), vec2(-1.435411, 0.435427), vec2(-1.492777, 0.147026),
    vec2(-1.492777, -0.147026), vec2(-1.435411, -0.435427), vec2(-1.322882, -0.707095), vec2(-1.159516, -0.951590),
    vec2(-0.951590, -1.159516), vec2(-0.707095, -1.322882), vec2(-0.435427, -1.435411), vec2(-0.147026, -1.492777),
    vec2(0.147026, -1.492777), vec2(0.435427, -1.435411), vec2(0.707095, -1.322882), vec2(0.951590, -1.159516),
    vec2(1.159516, -0.951590), vec2(1.322882, -0.707095), vec2(1.435411, -0.435427), vec2(1.492777, -0.147026)
);
vec3 getRayDir() {
    vec4 ndcPos;
    ndcPos.xy = 2.0 * gl_FragCoord.xy / vec2(width, height) - 1;
    ndcPos.z = (2.0 * gl_FragCoord.z - zNear - zFar) / (zFar - zNear);
    ndcPos.w = 1.0;
    vec4 clipPos = ndcPos;
    clipPos.z = 1.0;
    return normalize((inverse(vmat) * inverse(promat) * clipPos).xyz);
}
float computeScattering(float lightDotView)
{
    float result = 1.0 - G_SCATTERING * G_SCATTERING;
    result /= (4.0 * PI * pow(1.0 + G_SCATTERING * G_SCATTERING - (2.0 * G_SCATTERING) * lightDotView, 1.5));
    return result;
}
// float calViewZ(vec2 coord) {
//     float depth = texture(depthMap, coord).x;
//     return pmat[3][2] / (2 * depth - 1 - pmat[2][2]);
// }
vec3 normalFromDepth(float depth, vec2 texcoords) 
{
  vec2 offset1 = vec2(0.0,0.0001);
  vec2 offset2 = vec2(0.0001,0.0);
  vec2 offset3 = vec2(0.0,-0.0001);
  vec2 offset4 = vec2(-0.0001,0.0);
  
  float depth1 = texture2D(depthMap, texcoords + offset1).r;
  float depth2 = texture2D(depthMap, texcoords + offset2).r;
  float depth3 = texture2D(depthMap, texcoords + offset3).r;
  float depth4 = texture2D(depthMap, texcoords + offset4).r;
  
  vec3 p1 = vec3(offset1, depth1 - depth);
  vec3 p2 = vec3(offset2, depth2 - depth);
  vec3 p3 = vec3(offset3, depth3 - depth);
  vec3 p4 = vec3(offset4, depth4 - depth);
  
  vec3 normal1 = cross(p1, p2);
  vec3 normal2 = cross(p2, p3);
  vec3 normal3 = cross(p3, p4);
  vec3 normal4 = cross(p4, p1);
  vec3 normal = (normal1 + normal2 + normal3 + normal4) / 4;
  normal.z = -normal.z;
  
  return normalize(normal);
}
vec3 reflection(vec3 v1,vec3 v2)
{
    vec3 result= 2.0 * dot(v2, v1) * v2;
    result=v1-result;
    return result;
}
vec3 lensFlare(vec2 uv,vec2 pos)
{
	vec2 main = uv-pos;
	vec2 uvd = uv*(length(uv));
	
	float ang = atan(main.x,main.y);
	float dist=length(main); dist = pow(dist,.1);
	float n = vec2(ang*16.0,dist*32.0).x;
	
	float f0 = 1.0/(length(uv-pos)*16.0+1.0);
	
	f0 = f0 + f0*(sin((sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);
	
	float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;
	float f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;
	float f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;
	float f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;
	
	vec2 uvx = mix(uv,uvd,-0.5);
	
	float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;
	float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;
	float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;
	
	uvx = mix(uv,uvd,-.4);
	
	float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;
	float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;
	float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;
	
	uvx = mix(uv,uvd,-0.5);
	
	float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;
	float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;
	float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;
	
	vec3 c = vec3(.0);
	
	c.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;
	c = c*1.3 - vec3(length(uvd)*.05);
	//c+=vec3(f0);
	
	return c;
}
vec4 lookupTable(vec4 color){
    float blueColor = color.b * 63.0;
    vec2 quad1;
    quad1.y = floor(floor(blueColor) / 8.0);
    quad1.x = floor(blueColor) - (quad1.y * 8.0);
    vec2 quad2;
    quad2.y = floor(ceil(blueColor) / 8.0);
    quad2.x = ceil(blueColor) - (quad2.y * 8.0);
    //ivec2 size = textureSize(LUT, 0);
    vec2 texPos1;
    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    vec2 texPos2;
    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    vec4 newColor1 = texture(LUT, texPos1);
    vec4 newColor2 = texture(LUT, texPos2);
    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));
    return vec4(newColor.rgb, color.w);
}
bool allInRange(vec3 v, vec3 a, vec3 b)
{
    return all(lessThanEqual(a, v)) && all(lessThanEqual(v, b));
}
vec4 blur13(sampler2D image, sampler2D depth, vec2 uv, vec2 resolution, vec2 direction) {
    vec4 color = vec4(0.0);
    vec2 off1 = vec2(1.411764705882353) * direction / resolution;
    vec2 off2 = vec2(3.2941176470588234) * direction / resolution;
    vec2 off3 = vec2(5.176470588235294) * direction / resolution;
    float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv) * 0.1964825501511404;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off1).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off1) * 0.2969069646728344;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off1).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off1) * 0.2969069646728344;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off2).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off2) * 0.09447039785044732;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off2).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off2) * 0.09447039785044732;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off3).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off3) * 0.010381362401148057;
    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off3).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off3) * 0.010381362401148057;
    return color;
}
float CalcDistance(in vec3 c0, in vec3 c1) {
    vec3 sub = c0 - c1;
    return dot(sub, sub);
}
// Symmetric Nearest Neighbor
vec4 CalcSNN(in sampler2D iChannel0, in vec2 src_size, in vec2 uv) {
    vec3 c0 = texture(iChannel0, uv).rgb;
    float m0 = texture(extraMap_0, uv).r;
    if (m0 != 1)
        return vec4(c0, 1);
    vec2 inv_src_size = 1.0f / src_size;
    int half_width = 5;
    
    vec4 sum = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    
    for (int i = 0; i <= half_width; ++i) {
        vec2 uv1 = uv + vec2(+i, 0) * inv_src_size;
        vec2 uv2 = uv + vec2(-i, 0) * inv_src_size;
        float m1 = texture(extraMap_0, uv1).r;
        float m2 = texture(extraMap_0, uv2).r;
        if (m1 != 1 && m2 != 1) {
            continue;
        }
        else if (m1 == 1 && m2 != 1) {
            vec3 c = texture(iChannel0, uv1).rgb;
            sum.rgb += c;
        }
        else if (m1 != 1 && m2 == 1) {
            vec3 c = texture(iChannel0, uv2).rgb;
            sum.rgb += c;
        }
        else {
            vec3 c1 = texture(iChannel0, uv1).rgb;
            vec3 c2 = texture(iChannel0, uv2).rgb;
            
            float d1 = CalcDistance(c1, c0);
            float d2 = CalcDistance(c2, c0);
            if (d1 < d2) {
                sum.rgb += c1;
            } else {
                sum.rgb += c2;
            }
        }
        sum.a += 1.0f;
    }
 	for (int j = 1; j <= half_width; ++j) {
    	for (int i = -half_width; i <= half_width; ++i) {
            vec2 uv1 = uv + vec2(+i, +j) * inv_src_size;
            vec2 uv2 = uv + vec2(-i, -j) * inv_src_size;
            float m1 = texture(extraMap_0, uv1).r;
            float m2 = texture(extraMap_0, uv2).r;
            if (m1 != 1 && m2 != 1) {
                continue;
            }
            else if (m1 == 1 && m2 != 1) {
                vec3 c = texture(iChannel0, uv1).rgb;
                sum.rgb += c;
            }
            else if (m1 != 1 && m2 == 1) {
                vec3 c = texture(iChannel0, uv2).rgb;
                sum.rgb += c;
            }
            else {
                vec3 c1 = texture(iChannel0, uv1).rgb;
                vec3 c2 = texture(iChannel0, uv2).rgb;
                
                float d1 = CalcDistance(c1, c0);
                float d2 = CalcDistance(c2, c0);
                if (d1 < d2) {
                    sum.rgb += c1;
                } else {
                    sum.rgb += c2;
                }
            }
            sum.a += 1.0f;
		}
    }
    return sum / sum.a;
}
void main()
{
    if (pass == 0) {
        vec3 rayDir = getRayDir();
        //vec3 sunDir = normalize((lmat * vec4(1.0, 0, 0, 1.0)).xyz);
        vec3 step = rayDir * (fogDistance / floor(volumnicFogStep));
        vec3 curPos = camPos + step;//(ditherPattern * vec4(step, 1.0)).xyz;
        float fog = 0;
        for (int i = 0; i < volumnicFogStep; i++) {
            vec4 fragPosLightSpace = lmat * vec4(curPos, 1.0);
            vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
            projCoords = projCoords * 0.5 + 0.5;
            if (projCoords.z > 1.0)
                continue;
            float depthVal = texture(depthMap, projCoords.xy).r;
            if (depthVal > projCoords.z ) {
                fog += computeScattering(dot(rayDir, sunDir.xyz));
            }
            else
                break;
            curPos += step;
        }
        fog /= floor(volumnicFogStep);
        oCol0 = volumnicLightColor * fog;
        oCol0.a = 1.0;
    }
    else if (pass == 1) {
        vec4 c = vec4(0);
        int n = clamp(int(volumnicFogBlurIter), 0, 30);
        float volumnicFogOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - vec2(0, volumnicFogOffset / height * i));
            c += texture(screenMap, UV + vec2(0, volumnicFogOffset / height * i));
        }
        oCol0 = c / (floor(volumnicFogBlurIter) * 2.0);
        oCol0.a = 1.0;
    }
    else if (pass == 2) {
        vec4 f = vec4(0);
        int n = clamp(int(volumnicFogBlurIter), 0, 30);
        float volumnicFogOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            f += texture(volumnicFogMap, UV - vec2(volumnicFogOffset / width * i, 0));
            f += texture(volumnicFogMap, UV + vec2(volumnicFogOffset / width * i, 0));
        }
        vec3 fog = f.xyz / (floor(volumnicFogBlurIter) * 2.0);
        vec3 col = fog + vec3(texture(screenMap, UV)) * texture(ssaoMap, UV).r;
        oCol0 = vec4(col, 1.0);
        vec3 rate = smoothstep(bloomThreshold, bloomThreshold + 0.1, col) * col - vec3(bloomThreshold);
        oCol1.rgb = mix(bloomDarkIntensity * col, bloomLightIntensity * col, rate);
        oCol1.a = 1.0;
    }
    else if (pass == 3) {
        vec4 c = texture(screenMap, UV);
        c.rgb = vec3(1.0) - exp(-c.rgb * exposure);
        c.rgb = pow(c.rgb, vec3(1.0/gamma));
        oCol0 = c;
        oCol0.a = 1.0;
    }
    else if (pass == 4) {
        vec4 c = vec4(0);
        int n = clamp(int(bloomIter), 0, 30);
        float bloomOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - vec2(0, bloomOffset / height * i));
            c += texture(screenMap, UV + vec2(0, bloomOffset / height * i));
        }
        oCol0.rgb = (c / (n * 2.0)).rgb;
        oCol0.a = 1.0;
    }
    else if (pass == 5) {
        vec4 c = vec4(0);
        int n = clamp(int(bloomIter), 0, 30);
        float bloomOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - vec2(bloomOffset / width * i, 0));
            c += texture(screenMap, UV + vec2(bloomOffset / width * i, 0));
        }
        oCol0.rgb = (c / (n * 2.0)).rgb;
        oCol0.a = 1.0;
    }
    else if (pass == 6) {
        //vec4 c = texture(bloomMap_0, UV);
        vec4 c = texture(screenMap, UV) +
                 texture(bloomMap_0, UV) +
                 texture(bloomMap_1, UV) * 0.9 +
                 texture(bloomMap_2, UV) * 0.8 +
                 texture(bloomMap_3, UV) * 0.7 +
                 texture(bloomMap_4, UV) * 0.6 +
                 texture(bloomMap_5, UV) * 0.5;
        //c = clamp(c, 0.0, 1.0);
        c.rgb = vec3(1.0) - exp(-c.rgb * exposure);
        c.rgb = pow(c.rgb, vec3(1.0/gamma));
        oCol0 = c;
        oCol0.a = 1.0;
    }
    else if (pass == 7) {
    //     vec4 c = vec4(0);
    //     int n = int(blurIter);
    //    // float b2 = blurIter * blurIter;
    //     float blurOffset = n / 400.0;
    //     float weight = 0;
    //     vec4 cc = texture(screenMap, UV);// * (n - i);
    //     float w = length(cc.rgb) + 0.1;
    //     weight += w;
    //     c += cc * w;
        // for (int i = 1; i < n; i++) {
        //     float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - vec2(0, i / height)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap, UV - vec2(0, i / height));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        //     linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + vec2(0, i / height)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap, UV + vec2(0, i / height));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        // }
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         if ((i == 0 && j != 0) || (i != 0 && j == 0))
        //             continue;
        //         if ((i * i + j * j) >= n * n )
        //             continue;
        //         vec2 off = vec2(i / width, j / height);
        //         float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         off.x *= -1;
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //     }
        // }
        float weight = 0;
        vec3 c = vec3(0);
        int n = blurIter < 1 ? 1 : (blurIter < 2 ? 9 : (blurIter < 3 ? 25 : 57));
        for (int i = 0; i < n; i++) {
            vec2 off = dofKernel[i] * blurRadius;
            off.x /= width;
            off.y /= height;
            float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
            float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) +
                smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth);
            if (rate != 0) {
                vec3 cc = texture(screenMap, UV + off * rate).rgb;
                float w = length(cc) + 0.1;
                weight += w;
                c += cc * w;
            }
        }
        oCol0.rgb = c / weight;//((1 + n) * n);
        oCol0.a = 1.0;
    }
    else if (pass == 8) {
        // vec4 c = vec4(0);
        // int n = int(blurIter);
        // //float b2 = blurIter * blurIter;
        // float blurOffset = n / 400.0;
        // float weight = 0;
        // vec4 cc = texture(screenMap, UV);// * (n - i);
        // float w = length(cc.rgb) + 0.1;
        // weight += w;
        // c += cc * w;
        // for (int i = 1; i < n; i++) {
        //     float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap,  UV - vec2(i / width, 0)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap,  UV - vec2(i / width, 0));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        //     linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap,  UV + vec2(i / width, 0)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap,  UV + vec2(i / width, 0));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        // }
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         if ((i * i + j * j) >= n * n )
        //             continue;
        //         vec2 off = vec2((i + n / 2) / width, (j + n / 2) / height);
        //         float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         off.x *= -1;
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //     }
        // }
        oCol0.rgb = texture(screenMap, UV).rgb;//c.rgb / weight;//((1 + n) * n);
        oCol0.a = 1.0;
    }
    else if (pass == 9) {
        float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV).r - 1.0) * (zFar - zNear));
        vec4 blurC = texture(blurMap, UV);
        vec4 screenC = CalcSNN(screenMap, vec2(width, height), UV);//enableSNN == 0 ? texture(screenMap, UV) : CalcSNN(screenMap, vec2(width, height), UV);
        float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) * blurNearIntensity +
            smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth) * blurFarIntensity;
        // float rate = (linearDepth <= (blurNear + blurSmoothNear) ? 1 : 0) * blurNearIntensity +
        //     (linearDepth >= (blurFar - blurSmoothFar) ? 1 : 0) * blurFarIntensity;
        oCol0 = mix(screenC, blurC, rate);
        float aspect = float(height) / float(width);
        vec4 sunPos = promat * vmat * vec4(camPos + sunDir.xyz, 1.0);
        sunPos /= sunPos.w;
        vec2 viewSca = vec2(1) - pow(sunPos.xy, vec2(2));
        if (all(greaterThan(viewSca, vec2(0)))) {
            vec3 flare = lensFlare((UV - vec2(0.5)) * vec2(1, aspect) * 2.0, sunPos.xy * vec2(1, aspect)) * lensFlareColor.rgb * abs(viewSca.x * viewSca.y);
            oCol0.xyz = mix(oCol0.xyz, flare, flare);
        }
        oCol0 = mix(oCol0, tan(lookupTable(atan(oCol0) * (2.0 / PI)) * (PI / 2.0)), lutBlend);
        oCol0.a = 1;
    }
    else if (pass == 10) {
        // vec3 pos = reconstructPos();
        // float AO = 0.0;
        // for (int i = 0 ; i < 16 ; i++) {
        //     vec3 samplePos = pos + ssaoKernal[i];
        //     vec4 offset = vec4(samplePos, 1.0);
        //     offset = pmat * offset;
        //     offset.xy /= offset.w;
        //     offset.xy = offset.xy * 0.5 + 0.5;
        //     float sampleDepth = calViewZ(offset.xy);
        //     // float rangeCheck = smoothstep(0.0, 1.0, ssaoRadius / abs(pos.z - sampleDepth));
        //     // AO += (sampleDepth >= samplePos.z ? 1.0 : 0.0) * rangeCheck;
        //     if (abs(pos.z - sampleDepth) < ssaoRadius) {
        //         AO += step(sampleDepth,samplePos.z);
        //     }
        // }
        // AO = 1.0 - AO / 16.0;
        // oCol0.rgb = vec3(AO * AO);
        // oCol0.a = 1.0;
        float depth = texture2D(depthMap, UV).r;
        vec3 normal = normalFromDepth(depth, UV);
        if (depth < ssaoCutoff && abs(dot(normal, vec3(0, 0, 1))) < (1 - ssaobias)) {
            vec3 random = normalize(texture2D(ssaoKernalMap, UV * 8.0).rgb);
            vec3 position = vec3(UV.x,UV.y,depth);
            float radiusDepth = ssaoRadius/depth;
            float occlusion = 0.0;
            //float bias = max(ssaobias * dot(normal, vec3(0, 0, 1)), ssaobias * 0.1);
            int iterations = 16;
            for (int j = 0; j < iterations; ++j)
            {
                vec3 ray = radiusDepth * reflection(sample_sphere[j], random);
                if (dot(ray,normal) > 0) {
                    vec3 hemiRay = position + ray;
                
                    float occDepth = texture2D(depthMap, clamp(hemiRay.xy,0.0,1.0)).r;
                    float difference = depth - occDepth;
                    occlusion += smoothstep(ssaoFalloff, ssaoArea, (depth >= occDepth ? 1.0 : 0.0) * (1 - smoothstep(0, 1, abs(difference) / ssaoRadius)));
                }
                //occlusion += step(ssaoFalloff, difference) * smoothstep(ssaoFalloff, ssaoArea, difference);
            }
            float ao = occlusion * (1.0 / iterations);
            ao = smoothstep(ssaoFalloff, ssaoArea, ao) * ssaoIntensity * ao;
            ao = 1 - ao;
            float final = clamp(ao * ao,0.0,1.0);
            oCol0 = vec4(final,final,final,1);
        }
        else
            oCol0 = vec4(1);
    }
    if (pass == 11) {
        vec4 c = vec4(0);
        int n = clamp(int(ssaoBlurIter), 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - vec2(0, ssaoOffset / height * i));
            c += texture(ssaoMap, UV + vec2(0, ssaoOffset / height * i));
        }
        oCol0 = c / (n * 2.0);
        oCol0.a = 1.0;
    }
    if (pass == 12) {
        vec4 c = vec4(0);
        int n = clamp(int(ssaoBlurIter), 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - vec2(ssaoOffset / width * i, 0));
            c += texture(ssaoMap, UV + vec2(ssaoOffset / width * i, 0));
        }
        oCol0 = c / (n * 2.0);
        oCol0.a = 1.0;
    }
}

[Error][0:0:2:51]PostProcessing.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PostProcessing.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\PostProcessing.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:51]Engine/Shaders/PostProcessing.mat load
[Log][0:0:2:53]Engine/Shaders/Toon.mat load
[Log][0:0:2:61]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 ssnMask;
in vec3 Normal;
in vec2 TexCoords;
in vec4 lightSpacePos;
in vec3 WorldPos;
uniform vec4 baseColor;
uniform sampler2D colorMap;
uniform vec4 shadowColor;
uniform vec4 highlightColor;
uniform vec4 rimColor;
uniform vec4 overColor;
uniform float shadowCut;
uniform float shadowCutSmooth;
uniform float highlightCut;
uniform float highlightCutSmooth;
uniform float rimCut;
uniform float rimCutSmooth;
uniform float normalScale;
uniform sampler2D normalMap;
uniform sampler2D depthMap;
const mat4 thresholdMatrix = mat4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
vec4 smoothToon(vec4 base, vec4 over, float value, float cut, float smoothValue)
{
    float hs = clamp(smoothValue, 0.0f, 1.0f) / 2.0f;
    return mix(over, base, smoothstep(max(0.0f, cut - hs), min(1.0f, cut + hs), value));
}
void main()
{
    vec3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale);
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 albedo = texture(colorMap, TexCoords);
    float a = albedo.a * baseColor.a;
    ivec2 pos = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y));
    if (a < thresholdMatrix[(pos.x % 4)][(pos.y % 4)])
        discard;
        
    vec3 L = normalize(directLight.direction);
    vec3 H = normalize(V + L);
    vec4 ambience = mix(baseColor, highlightColor, smoothToon(vec4(1.0f), vec4(0.0f), dot(N, H), highlightCut, highlightCutSmooth));
    ambience = mix(shadowColor, ambience, ShadowCalculation(depthMap, lightSpacePos, N, L));
    ambience = smoothToon(ambience, shadowColor, dot(N, L), shadowCut, shadowCutSmooth);
    ambience = smoothToon(rimColor, ambience, fresnelSchlick(dot(N, normalize(camData.camPos - WorldPos)), 0.33f), rimCut, rimCutSmooth);
    FragColor = albedo * ambience;
    FragColor.a = a;
    FragColor *= overColor;
    ssnMask = vec4(1);
}

[Error][0:0:2:61]Toon_Dither.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_Dither.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_Dither.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:62]Engine/Shaders/Toon_Dither.mat load
[Error][0:0:2:65]Engine/Shaders/Toon_Face_Flat.mat Toon_Face_Flat load failed
[Log][0:0:2:67]Engine/Shaders/Toon_IBL.mat load
[Log][0:0:2:69]Engine/Shaders/Toon_IBL_Transparent.mat load
[Log][0:0:2:71]Engine/Shaders/Toon_Transparent.mat load
[Log][0:0:2:79]Fragment Shader
#version 460 core
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct PointLight
{
    vec3 pos;
    float intensity;
    vec3 color;
    float attenuation;
};
struct DirectLight
{
    vec3 direction;
    float intensity;
    mat4 lmat;
    vec3 color;
};
layout (std430, binding = LIGHT_BIND_INDEX) buffer CB6
{
    DirectLight directLight;
    uint pointLightCount;
    PointLight pointLights[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) out vec4 FragColor;
//layout (location = 1) out vec4 ssnMask;
in vec3 Normal;
in vec2 TexCoords;
in vec4 lightSpacePos;
in vec3 WorldPos;
uniform vec4 baseColor;
uniform vec4 shadowColor;
uniform vec4 highlightColor;
uniform vec4 rimColor;
uniform vec4 overColor;
uniform vec4 uvScale;
uniform float shadowCut;
uniform float shadowCutSmooth;
uniform float highlightCut;
uniform float highlightCutSmooth;
uniform float rimCut;
uniform float rimCutSmooth;
uniform float normalScale;
uniform sampler2D colorMap;
uniform sampler2D normalMap;
uniform sampler2D depthMap;
#define LOCAL_SIZE_1D 1024
#define LOCAL_SIZE_2D 16
#define MAX_SHARED_SIZE_1D 12288
#define MAX_SHARED_SIZE_2D 96
const float PI = 3.14159265359;
mat3 cotangent( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}
float ShadowCalculation(in sampler2D depthMap, vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}
vec2 sphereProj(vec3 v)
{
    vec3 zp = normalize(vec3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return vec2(s, t);
}
vec4 smoothToon(vec4 base, vec4 over, float value, float cut, float smoothValue)
{
    float hs = clamp(smoothValue, 0.0f, 1.0f) / 2.0f;
    return mix(over, base, smoothstep(max(0.0f, cut - hs), min(1.0f, cut + hs), value));
}
float ShadowCalculation(vec4 fragPosLightSpace, vec3 N, vec3 L)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;
    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.00005 * (1.0 - dot(N, L)), 0.000005);
    vec2 texelSize = 1.0 / textureSize(depthMap, 0);
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = texture(depthMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;
        }
    }
    shadow /= 49.0;
    return shadow;
}
void main()
{
    vec2 UV = TexCoords * uvScale.xy;
    vec3 N = normalize(cotangent(Normal, WorldPos, UV) * ((normalize(texture(normalMap, UV) * 2 - 1)).xyz) * normalScale);
    vec3 V = normalize(camData.camPos - WorldPos);
    vec4 albedo = texture(colorMap, UV);
    float a = albedo.a * baseColor.a;
    vec3 L = normalize(directLight.direction);
    vec3 H = normalize(V + L);
    vec4 ambience = mix(baseColor, highlightColor, smoothToon(vec4(1.0f), vec4(0.0f), dot(N, H), highlightCut, highlightCutSmooth));
    ambience = mix(shadowColor, ambience, ShadowCalculation(lightSpacePos, N, L));
    ambience = smoothToon(ambience, shadowColor, dot(N, L), shadowCut, shadowCutSmooth);
    ambience = smoothToon(rimColor, ambience, fresnelSchlick(dot(N, normalize(camData.camPos - WorldPos)), 0.33f), rimCut, rimCutSmooth);
    FragColor = albedo * ambience;
    FragColor.a = a;
    FragColor *= overColor;
    //ssnMask = vec4(1);
}

[Error][0:0:2:80]Toon_UV.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_UV.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Toon_UV.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:80]Engine/Shaders/Toon_UV.mat load
[Error][0:0:2:81]Engine/Shaders/VolumatricCloud.mat VolumatricCloud load failed
[Log][0:0:2:81]Engine/Shapes folder
[Log][0:0:2:89]Engine/Shapes/column.fbx load
[Log][0:0:2:115]Engine/Shapes/Cone.fbx load
[Log][0:0:2:128]Engine/Shapes/hemisphere.fbx load
[Log][0:0:2:135]Engine/Shapes/UnitBox.obj load
[Log][0:0:2:155]Engine/Shapes/UnitSphere.fbx load
[Log][0:0:2:155]Engine/SkySphere folder
[Log][0:0:2:176]Engine/SkySphere/Clouds.tga load
[Log][0:0:2:181]Vertex Shader
#version 460
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
out vec3 LocalPos;
out vec3 WorldPos;
out vec2 TexCoords;
void main() {
    mat4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    gl_Position = camData.pmat * fm * vec4(pos.x, pos.y, pos.z, 1.0);
    LocalPos = pos;
    vec4 w = fm * vec4(pos.x, pos.y, pos.z, 1.0);
    WorldPos = w.xyz / w.w;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:2:181]Sky.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Sky.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Sky.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:184]Fragment Shader
#version 460
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
uniform vec4 sunColor;
uniform vec4 cloudColor;
uniform vec4 zenithColor;
uniform vec4 horizonColor;
uniform vec4 overallColor;
uniform vec4 lightDirection;
uniform float cloudOpacity;
uniform float starBrightness;
uniform float sunBrightness;
uniform float sunHeight;
uniform float sunRadius;
uniform float radius;
uniform float time;
uniform float cloudSpeed;
uniform float lowNoisePower;
uniform float highNoisePower;
uniform float horizonFalloff;
uniform sampler2D cloudNoiseMap;
uniform sampler2D skyMap;
uniform sampler2D starMap;
in vec3 LocalPos;
in vec3 WorldPos;
in vec2 TexCoords;
out vec4 oCol;
float sphereMask(float pos, float center, float radius, float hardness) {
    return clamp((1 - abs(pos - center) / radius) / (1 - hardness), 0, 1);
}
void main() {
    vec3 cameraVector = normalize(WorldPos - camData.camPos);
    float cutoff = clamp(dot(cameraVector, vec3(0, 0, 1)), 0, 1);
    float cloudAlpha = cloudOpacity * (1 - clamp((LocalPos / radius * -10).b, 0, 1));
    float offset = time * cloudSpeed;
    float cloud = texture(cloudNoiseMap, vec2(offset + TexCoords.x, TexCoords.y)).r;
    float sky = texture(skyMap, vec2(offset + TexCoords.x, TexCoords.y)).r;
    cloudAlpha = mix(0, mix(sky, cloud, cutoff), cloudAlpha);
    float power = texture(cloudNoiseMap, TexCoords).r;
    power = mix(lowNoisePower, highNoisePower, power);
    power = pow(cloudAlpha, power);
    vec4 rimLight = cloudColor * power;
    power *= power;
    float sunVal = dot(normalize(lightDirection.xyz), cameraVector);
    rimLight += clamp(pow(sphereMask(sunVal, 1, 1.3, 0), 10), 0, 1) * sunColor * power * 0.4;
    vec4 sunCol = sphereMask(sunVal, 1, sunRadius, 0) * sunBrightness * sunColor;
    cutoff = clamp(pow(1 - cutoff, horizonFalloff), 0, 1);
    vec4 SkyCol = zenithColor + texture(starMap, TexCoords) * starBrightness * sunHeight;
    SkyCol = mix(SkyCol, horizonColor, cutoff);
    oCol = sunCol + SkyCol;
    oCol = mix(oCol, rimLight, clamp(power, 0, 1)) * overallColor * 1.5;
    // float gamma = 1.8;
    // vec3 mapped = vec3(1.0) - exp(-oCol.xyz);
    // mapped = pow(mapped, vec3(1.0 / gamma));
    // oCol = vec4(mapped, 1.0);
}

[Error][0:0:2:184]Sky.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Sky.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Sky.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:185]Engine/SkySphere/Sky.mat load
[Log][0:0:2:228]Engine/SkySphere/Sky.tga load
[Log][0:0:2:232]Vertex Shader
#version 460
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
layout (std430, binding = TRANS_BIND_INDEX) buffer CB0
{
    mat4 Transforms[];
};
layout (std430, binding = TRANS_INDEX_BIND_INDEX) buffer CB5
{
    uint ObjectIDs[];
};
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;
layout (location = 2) in vec3 norm;
out vec3 LocalPos;
out vec3 WorldPos;
out vec2 TexCoords;
void main() {
    gl_Position = camData.pmat * Transforms[gl_InstanceID + gl_BaseInstance] * vec4(pos.x, pos.y, pos.z, 1.0);
    LocalPos = pos;
    vec4 w = Transforms[gl_InstanceID + gl_BaseInstance] * vec4(pos.x, pos.y, pos.z, 1.0);
    WorldPos = w.xyz / w.w;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

[Error][0:0:2:232]Space.mat (Vertex Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Space.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Space.mat(11,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:234]Fragment Shader
#version 460
layout(early_fragment_tests) in;
#define VERTEX_MAX_BONE 4
#define TRANS_BIND_INDEX 0
#define MORPHDATA_BIND_INDEX 1
#define MORPHWEIGHT_BIND_INDEX 2
#define PARTICLE_BIND_INDEX 3
#define MODIFIER_BIND_INDEX 4
#define TRANS_INDEX_BIND_INDEX 5
#define LIGHT_BIND_INDEX 6
#define CAM_BIND_INDEX 7
struct CameraData
{
    mat4 pmat;
    mat4 promat;
    mat4 vmat;
    vec3 camPos;
    float zNear;
    vec3 camDir;
    float zFar;
    vec3 camUp;
    float fovy;
    vec3 camLeft;
    float user1;
    vec2 viewSize;
    vec2 user2;
};
layout (std140, binding = CAM_BIND_INDEX) uniform CamB
{
    CameraData camData;
};
uniform vec4 sunColor;
uniform vec4 overallColor;
uniform vec4 lightDirection;
uniform float sunBrightness;
uniform float sunHeight;
uniform float sunRadius;
uniform float radius;
uniform sampler2D skyMap;
in vec3 LocalPos;
in vec3 WorldPos;
in vec2 TexCoords;
out vec4 oCol;
float sphereMask(float pos, float center, float radius, float hardness) {
    return clamp((1 - abs(pos - center) / radius) / (1 - hardness), 0, 1);
}
void main() {
    vec3 cameraVector = normalize(WorldPos - camData.camPos);
    float sunVal = dot(normalize(lightDirection.xyz), cameraVector);
    vec4 sunCol = sphereMask(sunVal, 1, sunRadius, 0) * sunBrightness * sunColor;
    vec4 SkyCol = texture(skyMap, TexCoords);
    oCol = sunCol + SkyCol;
    oCol = oCol * overallColor * 1.5;
}

[Error][0:0:2:235]Space.mat (Fragment Shader) compile failed:
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Space.mat(1,2-8): error X1504: invalid preprocessor command 'version'
C:\Users\MC117\Documents\Visual Studio 2019\Projects\BraneEngineDx\BraneEngineDx\Space.mat(2,1-6): error X3000: unrecognized identifier 'layout'

[Log][0:0:2:235]Engine/SkySphere/Space.mat load
[Log][0:0:2:485]Engine/SkySphere/Sphere.obj load
[Log][0:0:2:561]Engine/SkySphere/Sphere1.obj load
[Log][0:0:2:564]Engine/SkySphere/Stars.tga load
[Log][0:0:2:565]Engine/Textures folder
[Error][0:0:2:565]Engine/Textures/Black.png Black load failed
[Error][0:0:2:565]Engine/Textures/default_lut.png default_lut load failed
[Log][0:0:2:567]Engine/Textures/Default_N.png load
[Log][0:0:2:594]Engine/Textures/env.jpg load
[Log][0:0:2:596]Engine/Textures/env_ir.tga load
[Log][0:0:2:601]Engine/Textures/env_prefilter.mip load
[Log][0:0:2:653]Engine/Textures/GridInfo.png load
[Error][0:0:2:654]Engine/Textures/ibl_brdf_lut.png ibl_brdf_lut load failed
[Log][0:0:2:730]Engine/Textures/ibl_hdr_radiance.png load
[Log][0:0:2:731]Engine/Textures/Smoke.tga load
[Log][0:0:2:779]Engine/Textures/SmokeNoise.png load
[Log][0:0:2:853]Engine/Textures/SpaceBox.tga load
[Log][0:0:2:855]Engine/Textures/SpaceBox_irr.tga load
[Log][0:0:2:877]Engine/Textures/SpaceBox_prefilter.mip load
[Log][0:0:3:153]Engine/Textures/ssaoRand.png load
[Log][0:0:3:227]Engine/Textures/ssaoRand1.jpg load
[Log][0:0:3:252]Engine/Textures/StarTexP.tga load
[Error][0:0:3:253]Engine/Textures/White.png White load failed
