#order 2450
#noearlyz
#castshadow false
#material
Scalar noiseUVScale: 500
Scalar lightFactor: 0.5
Scalar darkCut: 0.5
Scalar darkSmooth: 0.5
Scalar alphaCut: 0.5
Scalar time: 0
Scalar windDensity: 1
Color baseColor: 255, 255, 255, 255
Color darkColor: 255, 255, 255, 255
Color shadowColor: 150, 150, 150, 255
Color noiseColor: 150, 150, 150, 255
Color overColor: 255, 255, 255, 255
Color windForce: 2.0, 2.0, 0.0, 0.0
Texture colorMap: white
Texture noiseMap: black
Texture depthMap: white
#vertex
#version 460 core
#include "lib/TransformData_def.hmat"
#include "lib/CameraData_Def.hmat"
#include "lib/Light_Def.hmat"
#include "lib/MeshData_Def.hmat"

out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

uniform float time;
uniform float windDensity;
uniform float4 windForce;

float2 random2(float2 st){
    st = float2( dot(st,float2(127.1,311.7)),
              dot(st,float2(269.5,183.3)) );
    return -1.0 + 2.0*fract(sin(st)*43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = fract(st);

    float2 u = f*f*(3.0-2.0*f);

    return mix( mix( dot( random2(i + float2(0.0,0.0) ), f - float2(0.0,0.0) ),
                     dot( random2(i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                mix( dot( random2(i + float2(0.0,1.0) ), f - float2(0.0,1.0) ),
                     dot( random2(i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
}

void main() {
    float4x4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    float4 _WorldPos = fm * float4(pos, 1.0);

    float2 offset = (noise((_WorldPos.xz + time * normalize(windForce.xy)) *
        windDensity) - 0.5) * windForce.xy;
    
    _WorldPos.xy += offset * uv.y;

    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}

#fragment
#version 460 core

#include "lib/Light_Def.hmat"
#include "lib/CameraData_Def.hmat"
#include "lib/Toon_Lib.hmat"

const float4x4 thresholdMatrix = float4x4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);

layout (location = 0) out float4 FragColor;
layout (location = 1) out float4 ssnMask;
in float3 Normal;
in float2 TexCoords;
in float4 lightSpacePos;
in float3 WorldPos;

uniform float noiseUVScale;
uniform float lightFactor;
uniform float darkCut;
uniform float darkSmooth;
uniform float alphaCut;
uniform float4 baseColor;
uniform float4 darkColor;
uniform float4 shadowColor;
uniform float4 noiseColor;
uniform float4 overColor;
uniform sampler2D colorMap;
uniform sampler2D noiseMap;
uniform sampler2D depthMap;

void main() {
    float4 color = texture(colorMap, TexCoords);
    if (color.a < alphaCut)
        discard;

    float3 L = normalize(directLight.direction);
    float4 ambience = smoothToon(darkColor, baseColor, TexCoords.y, darkCut, darkSmooth);
    ambience.rgb *= mix(float3(1), directLight.color, lightFactor);
    float shadowFactor = ShadowCalculation(depthMap, lightSpacePos, Normal, L);
    ambience = mix(shadowColor, ambience, shadowFactor);
    ambience *= mix(overColor, noiseColor, texture(noiseMap, WorldPos.xy / noiseUVScale));
    
    FragColor = color * ambience;
    ssnMask = float4(1);
}