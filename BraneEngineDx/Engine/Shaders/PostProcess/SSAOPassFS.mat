#material
Scalar ssaoRadius: 0.02
Scalar ssaoIntensity: 1.0
Scalar ssaoArea: 0.8
Scalar ssaoFalloff: 0.2
Scalar ssaoCutoff: 0.999999
Scalar ssaobias: 0
Scalar screenScale: 1
Count ssaoBlurIter: 10
Texture ssaoMap
Texture ssaoKernalMap
Texture depthMap
#vertex use postprocess
#fragment postprocess
#include "../lib/Basic_FS_Lib.hmat"
#include "../lib/PostProcess_Def.hmat"
#include "../lib/CameraData_Def.hmat"

FS_DEF_OUT_BEGIN
FS_DEF_OUT_COLOR(FragColor, 0);
FS_DEF_OUT_END

DEF_MAT_BEGIN
uniform float ssaoRadius;
uniform float ssaoIntensity;
uniform float ssaoArea;
uniform float ssaoFalloff;
uniform float ssaoCutoff;
uniform float ssaobias;
uniform int ssaoBlurIter;
uniform float screenScale;
DEF_MAT_END

DEF_TEX2D(ssaoMap, 0);
DEF_TEX2D(ssaoKernalMap, 1);
DEF_TEX2D(depthMap, 2);

static const float3 sample_sphere[16] = {
    float3( 0.5381, 0.1856,-0.4319), float3( 0.1379, 0.2486, 0.4430),
    float3( 0.3371, 0.5679,-0.0057), float3(-0.6999,-0.0451,-0.0019),
    float3( 0.0689,-0.1598,-0.8547), float3( 0.0560, 0.0069,-0.1843),
    float3(-0.0146, 0.1402, 0.0762), float3( 0.0100,-0.1924,-0.0344),
    float3(-0.3577,-0.5301,-0.4358), float3(-0.3169, 0.1063, 0.0158),
    float3( 0.0103,-0.5869, 0.0046), float3(-0.0897,-0.4940, 0.3287),
    float3( 0.7119,-0.0154,-0.0918), float3(-0.0533, 0.0596,-0.5411),
    float3( 0.0352,-0.0631, 0.5460), float3(-0.4776, 0.2847,-0.0271)
};

float3 normalFromDepth(in float depth, in float2 texcoords) 
{
	float2 offset1 = float2(0.0,0.0001);
	float2 offset2 = float2(0.0001,0.0);
	float2 offset3 = float2(0.0,-0.0001);
	float2 offset4 = float2(-0.0001,0.0);

	float depth1 = SAMPLE_TEX_LOD(depthMap, texcoords + offset1, 0).r;
	float depth2 = SAMPLE_TEX_LOD(depthMap, texcoords + offset2, 0).r;
	float depth3 = SAMPLE_TEX_LOD(depthMap, texcoords + offset3, 0).r;
	float depth4 = SAMPLE_TEX_LOD(depthMap, texcoords + offset4, 0).r;

	float3 p1 = float3(offset1, depth1 - depth);
	float3 p2 = float3(offset2, depth2 - depth);
	float3 p3 = float3(offset3, depth3 - depth);
	float3 p4 = float3(offset4, depth4 - depth);

	float3 normal1 = cross(p1, p2);
	float3 normal2 = cross(p2, p3);
	float3 normal3 = cross(p3, p4);
	float3 normal4 = cross(p4, p1);

	float3 normal = (normal1 + normal2 + normal3 + normal4) / 4;
	normal.z = -normal.z;

	return normalize(normal);
}

float3 reflection(float3 v1,float3 v2)
{
    float3 result= 2.0 * dot(v2, v1) * v2;
    result=v1-result;
    return result;
}

FragmentOut DEFAULT_PP_MAIN
{
	FragmentOut fout;
	float width = floor(camData.viewSize.x * screenScale);
	float height = floor(camData.viewSize.y * screenScale);
    if (passID == 0) {
        // float3 pos = reconstructPos();
        // float AO = 0.0;

        // for (int i = 0 ; i < 16 ; i++) {
        //     float3 samplePos = pos + ssaoKernal[i];
        //     float4 offset = float4(samplePos, 1.0);
        //     offset = camData.pmat * offset;
        //     offset.xy /= offset.w;
        //     offset.xy = offset.xy * 0.5 + 0.5;

        //     float sampleDepth = calViewZ(offset.xy);

        //     // float rangeCheck = smoothstep(0.0, 1.0, ssaoRadius / abs(pos.z - sampleDepth));
        //     // AO += (sampleDepth >= samplePos.z ? 1.0 : 0.0) * rangeCheck;

        //     if (abs(pos.z - sampleDepth) < ssaoRadius) {
        //         AO += step(sampleDepth,samplePos.z);
        //     }
        // }
        // AO = 1.0 - AO / 16.0;
        // oCol0.rgb = float3(AO * AO);
        // oCol0.a = 1.0;
        float depth = SAMPLE_TEX_LOD(depthMap, pin.UV, 0).r;
        float3 normal = normalFromDepth(depth, pin.UV);
        if (depth < ssaoCutoff && abs(dot(normal, float3(0, 0, 1))) < (1 - ssaobias)) {
            float3 random = normalize(SAMPLE_TEX_LOD(ssaoKernalMap, pin.UV * 8.0, 0).rgb);
            float3 position = float3(pin.UV.x,pin.UV.y,depth);
            float radiusDepth = ssaoRadius/depth;
            float occlusion = 0.0;
            //float bias = max(ssaobias * dot(normal, float3(0, 0, 1)), ssaobias * 0.1);

            int iterations = 16;
            for (int j = 0; j < iterations; ++j)
            {
                float3 ray = radiusDepth * reflection(sample_sphere[j], random);
                if (dot(ray,normal) > 0) {
                    float3 hemiRay = position + ray;
                
                    float occDepth = SAMPLE_TEX_LOD(depthMap, clamp(hemiRay.xy,0.0,1.0), 0).r;
                    float difference = depth - occDepth;

                    occlusion += smoothstep(ssaoFalloff, ssaoArea, (depth >= occDepth ? 1.0 : 0.0) * (1 - smoothstep(0, 1, abs(difference) / ssaoRadius)));
                }
                //occlusion += step(ssaoFalloff, difference) * smoothstep(ssaoFalloff, ssaoArea, difference);
            }

            float ao = occlusion * (1.0 / iterations);
            ao = smoothstep(ssaoFalloff, ssaoArea, ao) * ssaoIntensity * ao;
            ao = 1 - ao;
            float final = clamp(ao * ao,0.0,1.0);

            fout.FragColor = float4(final,final,final,1);
        }
        else
            fout.FragColor = Float4(1);
    }
    else if (passID == 1) {
        float4 c = Float4(0);
        int n = clamp(ssaoBlurIter, 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += SAMPLE_TEX_LOD(ssaoMap, pin.UV - float2(0, ssaoOffset / height * i), 0);
            c += SAMPLE_TEX_LOD(ssaoMap, pin.UV + float2(0, ssaoOffset / height * i), 0);
        }
        fout.FragColor = c / (n * 2.0);
        fout.FragColor.a = 1.0;
    }
    else if (passID == 2) {
        float4 c = Float4(0);
        int n = clamp(ssaoBlurIter, 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += SAMPLE_TEX_LOD(ssaoMap, pin.UV - float2(ssaoOffset / width * i, 0), 0);
            c += SAMPLE_TEX_LOD(ssaoMap, pin.UV + float2(ssaoOffset / width * i, 0), 0);
        }
        fout.FragColor = c / (n * 2.0);
        fout.FragColor.a = 1.0;
    }
    return fout;
}