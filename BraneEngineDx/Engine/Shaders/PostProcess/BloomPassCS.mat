#material
Scalar gamma: 0.25
Scalar exposure: 3
Scalar bloomLightIntensity: 5
Scalar bloomDarkIntensity: 2.5
Scalar bloomThreshold: 0.7
Count bloomLevel: 5
Count bloomIter: 5
Texture sampleMap
Image imageMap: binding(0)
#localsize 16 16
#compute postprocess
#version 460

#include "../lib/Const_Def.hmat"

uniform int pass;
uniform int bloomLevel;
uniform int bloomIter;
uniform float gamma;
uniform float exposure;
uniform float bloomLightIntensity;
uniform float bloomDarkIntensity;
uniform float bloomThreshold;
uniform sampler2D sampleMap;
layout(rgba8, binding = 0) uniform image2D imageMap;
layout(local_size_x = LOCAL_SIZE_2D, local_size_y = LOCAL_SIZE_2D) in;

// const int maxIter = MAX_SHARED_SIZE_2D - LOCAL_SIZE_2D / 2;
// shared float samples[MAX_SHARED_SIZE_2D][MAX_SHARED_SIZE_2D];

// void loadSharedData() {
//     int length = bloomIter * 2 + LOCAL_SIZE_2D;
// }
void syncronize()
{
	memoryBarrier();
	barrier();
}

void main() {
    ifloat2 pos = ifloat2(gl_GlobalInvocationID.xy);
	ifloat2 size = imageSize(imageMap);
	if (pos.x < size.x && pos.y < size.y) {
		float4 pixel = float4(0.0);
		float coef = 0.0;
        if (pass == 0) {
	        float2 uv = float2(pos.x / float(size.x), pos.y / float(size.y));
            pixel = texture(sampleMap, uv);
			float3 col = pixel.rgb;
            float3 rate = smoothstep(bloomThreshold, bloomThreshold + 0.1, col) * col - float3(bloomThreshold);
            col = mix(bloomDarkIntensity * col, bloomLightIntensity * col, rate);
			col = float3(1.0) - exp(-col * exposure);
        	col = pow(col, float3(1.0/gamma));
			pixel.rgb = col;
            imageStore(imageMap, pos, pixel);
        }
		if (pass == 1) {
			for (int dx = -bloomIter; dx <= bloomIter; dx++) {
				int x = pos.x + dx;
				if (x < 0 || x >= size.x) {
					continue;
				}
				float c = 1 - abs(dx) / float(bloomIter);
				c = c * c;
				pixel += imageLoad(imageMap, ifloat2(x, pos.y)) * c;
				coef += c;
			}
            syncronize();
			imageStore(imageMap, pos, pixel / coef);
		}
		else if (pass == 2) {
			for (int dy = -bloomIter; dy <= bloomIter; dy++) {
				int y = pos.y + dy;
				if (y < 0 || y >= size.y) {
					continue;
				}
				float c = 1 - abs(dy) / float(bloomIter);
				c = c * c;
				pixel += imageLoad(imageMap, ifloat2(pos.x, y)) * c;
				coef += c;
			}
            syncronize();
			imageStore(imageMap, pos, pixel / coef);
		}
        else if (pass == 3) {
	        float2 uv = float2(pos.x / float(size.x), pos.y / float(size.y));
            pixel = imageLoad(imageMap, pos);
            for (int i = 0; i < bloomLevel; i++) {
                pixel += textureLod(sampleMap, uv, i) * (1 - i * 0.1);
            }
            syncronize();
			imageStore(imageMap, pos, pixel);
        }
	}
}