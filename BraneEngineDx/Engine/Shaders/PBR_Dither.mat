#order 1000
#noearlyz
#material
Color baseColor: 255, 255, 255, 255
Texture colorMap: white
Scalar metallic: 0.5
Texture metallicMap: white
Scalar roughness: 0.5
Texture roughnessMap: white
Scalar ao: 1.0
Texture aoMap: white
Scalar normalScale: 1
Texture normalMap: black
Scalar emission: 0
Texture emissionMap: white
Texture depthMap: white
#vertex use default
#fragment
#version 460 core

#include "lib/Light_Def.hmat"
#include "lib/CameraData_Def.hmat"

layout (location = 0) out float4 FragColor;
in float2 TexCoords;
in float3 WorldPos;
in float3 Normal;
in float4 lightSpacePos;

uniform float4 baseColor;
uniform sampler2D colorMap;
uniform float metallic;
uniform sampler2D metallicMap;
uniform float roughness;
uniform sampler2D roughnessMap;
uniform float ao;
uniform sampler2D aoMap;
uniform float normalScale;
uniform sampler2D normalMap;
uniform float emission;
uniform sampler2D emissionMap;
uniform sampler2D depthMap;

const float4x4 thresholdMatrix = float4x4(
1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
);

#include "lib/PBR_Lib.hmat"
#include "lib/Basic_FS_Lib.hmat"

void main() {
    float4 _cm = texture(colorMap, TexCoords);
    float3 albedo = baseColor.rgb * _cm.rgb;
    float alpha = baseColor.a * _cm.a;
   
    ifloat2 pos = ifloat2(int(gl_FragCoord.x), int(gl_FragCoord.y));
    if (alpha < thresholdMatrix[(pos.x % 4)][(pos.y % 4)])
        discard;

    float3 N = normalize(cotangent(Normal, WorldPos, TexCoords) * ((normalize(texture(normalMap, TexCoords) * 2 - 1)).xyz) * normalScale) ;
    float3 V = normalize(camData.camPos - WorldPos);
    float _roughness = roughness * texture(roughnessMap, TexCoords).r;
    float _metallic = metallic * texture(metallicMap, TexCoords).r;
    float _ao = ao * texture(aoMap, TexCoords).r;

    float3 F0 = float3(0.04); 
    F0 = mix(F0, albedo, _metallic);

    // reflectance equation
    float3 Lo = float3(0.0);

    if (directLight.intensity != 0) {
        Lo += PBR_Lo_DirectLight(directLight, N, V, albedo, _metallic, _roughness) * ShadowCalculation(depthMap, lightSpacePos, N, directLight.direction);
    }

    for(int i = 0; i < pointLightCount; ++i) {
        if (pointLights[i].intensity != 0) {
            Lo += PBR_Lo_PointLight(pointLights[i], WorldPos, N, V, albedo, _metallic, _roughness);
        }
    }

    float3 ambient = PBR_Ambient(albedo, _ao);
    float3 emissionColor = texture(emissionMap, TexCoords).rgb;
    float3 color = ambient + Lo;//float3(emission.r * emissionColor.r, emission.g * emissionColor.g, emission.b * emissionColor.b);

    color = color / (color + float3(1.0));
    color = pow(color, float3(1.0/2.2)) + (emission * baseColor).rgb * emissionColor;
    
    FragColor = float4(color, alpha);
}