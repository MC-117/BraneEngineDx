#order 1000
#material
Color baseColor: 255, 255, 255, 255
Color UVScale: 1.0, 1.0, 1.0, 1.0
Texture colorMap: white
Scalar metallic: 0.5
Texture metallicMap: white
Scalar roughness: 0.5
Texture roughnessMap: white
Scalar ao: 1.0
Texture aoMap: white
Color reflectionColor: 255, 255, 255, 255
Texture reflectionMap: black
Texture irradianceMap: black
Scalar normalScale: 1
Texture normalMap: black
Scalar emission: 0
Texture emissionMap: white
Texture brdfLUT: brdfLUT
Texture depthMap: white
#vertex
#version 460 core
#include "lib/TransformData_def.hmat"
#include "lib/CameraData_Def.hmat"
#include "lib/Light_Def.hmat"
#include "lib/MeshData_Def.hmat"

uniform float4 UVScale;
out float3 WorldPos;
out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;

void main()
{
    float4x4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    float4 _WorldPos = fm * float4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}
#vertex skeleton
#version 460 core
#include "lib/TransformData_def.hmat"
#include "lib/CameraData_Def.hmat"
#include "lib/Light_Def.hmat"
#include "lib/SkeletonMeshData_Def.hmat"

uniform float4 UVScale;
out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

float4x4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    float4x4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}

void main()
{
    float4x4 fm = getFinalMat();
    float4 _WorldPos = fm * float4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}
#vertex skeleton morph
#version 460 core
#include "lib/TransformData_def.hmat"
#include "lib/CameraData_Def.hmat"
#include "lib/Light_Def.hmat"
#include "lib/SkeletonMeshData_Def.hmat"
#include "lib/MorphData_def.hmat"

uniform float4 UVScale;
out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

float3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    float3 w = float3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}

float3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    float3 w = float3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}

float4x4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    float4x4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}

void main()
{
    float4x4 fm = getFinalMat();
    float4 _WorldPos = fm * float4(morphPos(), 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * morphNorm());
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
    TexCoords.x *= UVScale.x;
    TexCoords.y *= UVScale.y;
}

#fragment use pbr_ibl_fragment