#material
Count hiZStartLevel: 5
Count hiZStopLevel: -1
Count hiZMaxStep: 20
Color hiZUVScale: 1.0, 1.0, 1.0, 1.0
#localsize 8 8
#compute

#include "../lib/Basic_FS_Lib.hmat"
#include "../lib/Light_Def.hmat"
#include "../lib/CameraData_Def.hmat"

DEF_MAT_BEGIN
uniform int hiZStartLevel;
uniform int hiZStopLevel;
uniform int hiZMaxStep;
uniform float4 hiZUVScale;
DEF_MAT_END

#define gBufferA inTexture0
#define gBufferB inTexture1
#define gBufferC inTexture2
#define hiZMap inTexture3

#define inHitColorMap inTexture0

#define hitDataMap rwTexture0
#define hitColorMap rwTexture1

#define outGBufferA rwTexture1

DEF_TEX2D(inTexture0, 0);
DEF_TEX2D(inTexture1, 1);
DEF_TEX2D(inTexture2, 2);
DEF_TEX2D(inTexture3, 3);

RWTexture2D<snorm float4> rwTexture0 : register(u0);
RWTexture2D<unorm float4> rwTexture1 : register(u1);

float getCellSize(float2 stepUV, float2 detailUVSize, float mipLevel)
{
    float2 size = detailUVSize * exp2(mipLevel + 1);
    return length(min(stepUV, size));
}

bool rayTraceHiZ(float3 dirUVZ, out float3 hitUVZ)
{
    bool hit = false;
    int mipLevel = hiZStartLevel;
    int stepNum = 0;
    float cellSize = getCellSize(dirUVZ.xy, hiZUVScale.zw, mipLevel);
    while(mipLevel > hiZStopLevel && stepNum < hiZMaxStep) {
        hitUVZ += dirUVZ * cellSize;
        float depth = SAMPLE_TEX_LOD(hiZMap, hitUVZ.xy * hiZUVScale.xy, mipLevel);
        if (hitUVZ.z > depth) {
            mipLevel--;
            cellSize = getCellSize(dirUVZ.xy, hiZUVScale.zw, mipLevel);
            hit = true;
        }
        else if (hitUVZ.z < depth && mipLevel < hiZStartLevel) {
            mipLevel++;
            cellSize = getCellSize(dirUVZ.xy, hiZUVScale.zw, mipLevel);
        }
        stepNum++;
    }
    return hit;
}

[numthreads(LOCAL_SIZE_X, LOCAL_SIZE_Y, LOCAL_SIZE_Z)]
void main(uint2 tid : SV_DispatchThreadID)
{
	uint2 size;
    size = rcp(hiZUVScale.zw) * 2.0f;
    if (tid.x < size.x && tid.y < size.y) {
        float2 UV = tid * hiZUVScale.zw * 0.5f;
        if (passID == 0) {
            float4 B = SAMPLE_TEX_LOD(gBufferB, UV, 0);
            float4 C = SAMPLE_TEX_LOD(gBufferC, UV, 0);
            float depth = B.r;
            float3 N = C.xyz;
            float roughness = C.a;

            float3 viewOriginPos = depthToViewOriginPos(float3(UV, depth));
            float3 V = normalize(viewOriginPos);

            float3x3 tangentBasis = getTangentBasis(N);
            float4 HPDF = importanceSampleGGX(float2(0, 0), roughness * roughness);
            float3 H = normalize(mul(HPDF.xyz, tangentBasis));
            float3 L = reflect(V, H);

            float3 startUVZ = float3(UV, depth);
            float4 dirClip = mul(mul(float4(L, 0), camData.vomat), camData.promat);
            dirClip /= dirClip.w;
            dirClip.xy *= float2(0.5, -0.5f);
            float3 dirUVZ = dirClip.xyz;
            float3 hitUVZ = startUVZ;
            float4 hitData, hitColor;
            if (rayTraceHiZ(dirUVZ, hitUVZ)) {
                hitData = float4(hitUVZ, HPDF.a);
                hitColor = SAMPLE_TEX_LOD(gBufferA, hitUVZ.xy, 0);
            }
            else {
                hitData = float4(hitUVZ, 0.0f);
                hitColor = 0.0f.rrrr;
            }

            hitDataMap[tid] = hitData;
            hitColorMap[tid] = hitColor;
        }
        else if (passID == 1) {
            float4 hitData = hitDataMap[tid];
            float4 hitColor = SAMPLE_TEX_LOD(inHitColorMap, UV, 0);
            float4 color = outGBufferA[tid];
            color.rgb += hitColor.rgb * hitData.a * 0.1;
            outGBufferA[tid] = color;
        }
    }
}