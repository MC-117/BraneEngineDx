#order 2500
#material
Scalar frequent: 1
Scalar raySteps: 5
Color baseColor: 255, 255, 255, 255
Color minPoint: 0, 0, 0, 255
Color maxPoint: 0, 0, 0, 255
#vertex
#version 460 core

#include "../lib/TransformData_def.hmat"
#include "../lib/CameraData_Def.hmat"
#include "../lib/MeshData_Def.hmat"

out float3 WorldPos;

void main()
{
    WorldPos = (Transforms[gl_InstanceID + gl_BaseInstance] * float4(pos.x, pos.y, pos.z, 1.0)).xyz;
    gl_Position = camData.pmat * float4(WorldPos, 1.0);
}
#fragment
#version 410 core
/**
This tab contains all the necessary noise functions required to model a cloud shape.
*/

// Hash by David_Hoskins
#define UI0 1597334673U
#define UI1 3812015801U
#define UI2 ufloat2(UI0, UI1)
#define UI3 ufloat3(UI0, UI1, 2798796415U)
#define UIF (1.0 / float(0xffffffffU))

#include "../lib/Light_Def.hmat"
#include "../lib/CameraData_Def.hmat"

in float3 WorldPos;
out float4 oCol;
uniform float frequent;
uniform float raySteps;
uniform float4 baseColor;
uniform float4 minPoint;
uniform float4 maxPoint;

float3 hash33(float3 p)
{
	ufloat3 q = ufloat3(ifloat3(p)) * UI3;
	q = (q.x ^ q.y ^ q.z)*UI3;
	return -1. + 2. * float3(q) * UIF;
}

float remap(float x, float a, float b, float c, float d)
{
    return (((x - a) / (b - a)) * (d - c)) + c;
}

float3 remap(float3 x, float3 a, float3 b, float3 c, float3 d)
{
    float3 re = float3(0);
    re.x = remap(x.x, a.x, b.x, c.x, d.x);
    re.y = remap(x.y, a.y, b.y, c.y, d.y);
    re.z = remap(x.z, a.z, b.z, c.z, d.z);
    return re;
}

// Gradient noise by iq (modified to be tileable)
float gradientNoise(float3 x, float freq)
{
    // grid
    float3 p = floor(x);
    float3 w = fract(x);
    
    // quintic interpolant
    float3 u = w * w * w * (w * (w * 6. - 15.) + 10.);

    
    // gradients
    float3 ga = hash33(mod(p + float3(0., 0., 0.), freq));
    float3 gb = hash33(mod(p + float3(1., 0., 0.), freq));
    float3 gc = hash33(mod(p + float3(0., 1., 0.), freq));
    float3 gd = hash33(mod(p + float3(1., 1., 0.), freq));
    float3 ge = hash33(mod(p + float3(0., 0., 1.), freq));
    float3 gf = hash33(mod(p + float3(1., 0., 1.), freq));
    float3 gg = hash33(mod(p + float3(0., 1., 1.), freq));
    float3 gh = hash33(mod(p + float3(1., 1., 1.), freq));
    
    // projections
    float va = dot(ga, w - float3(0., 0., 0.));
    float vb = dot(gb, w - float3(1., 0., 0.));
    float vc = dot(gc, w - float3(0., 1., 0.));
    float vd = dot(gd, w - float3(1., 1., 0.));
    float ve = dot(ge, w - float3(0., 0., 1.));
    float vf = dot(gf, w - float3(1., 0., 1.));
    float vg = dot(gg, w - float3(0., 1., 1.));
    float vh = dot(gh, w - float3(1., 1., 1.));
	
    // interpolation
    return va + 
           u.x * (vb - va) + 
           u.y * (vc - va) + 
           u.z * (ve - va) + 
           u.x * u.y * (va - vb - vc + vd) + 
           u.y * u.z * (va - vc - ve + vg) + 
           u.z * u.x * (va - vb - ve + vf) + 
           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
}

// Tileable 3D worley noise
float worleyNoise(float3 uv, float freq)
{    
    float3 id = floor(uv);
    float3 p = fract(uv);
    
    float minDist = 10000.;
    for (float x = -1.; x <= 1.; ++x)
    {
        for(float y = -1.; y <= 1.; ++y)
        {
            for(float z = -1.; z <= 1.; ++z)
            {
                float3 offset = float3(x, y, z);
            	float3 h = hash33(mod(id + offset, float3(freq))) * .4 + .3; // [.3, .7]
    			h += offset;
            	float3 d = p - h;
           		minDist = min(minDist, dot(d, d));
            }
        }
    }
    
    // inverted worley noise
    return 1. - minDist;
}

// Fbm for Perlin noise based on iq's blog
float perlinfbm(float3 p, float freq, int octaves)
{
    float G = exp2(-.85);
    float amp = 1.;
    float noise = 0.;
    for (int i = 0; i < octaves; ++i)
    {
        noise += amp * gradientNoise(p * freq, freq);
        freq *= 2.;
        amp *= G;
    }
    
    return noise;
}

// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes
// chapter in GPU Pro 7.
float worleyFbm(float3 p, float freq)
{
    return worleyNoise(p*freq, freq) * .625 +
        	 worleyNoise(p*freq*2., freq*2.) * .25 +
        	 worleyNoise(p*freq*4., freq*4.) * .125;
}

float cloudNoise(float3 p, float freq)
{
    float pfbm= mix(1., perlinfbm(p, freq, 3), .5);
    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise
    float pp = worleyFbm(p, freq);
    pfbm = remap(pfbm, 0., 1., pp, 1.); // perlin-worley

    float wfbm = pp * .625 +
        		 worleyFbm(p, freq * 2) * .125 +
        		 worleyFbm(p, freq * 4) * .25;

    float _cloud = remap(pfbm, wfbm - 1., 1., 0., 1.);
    _cloud = remap(_cloud, .85, 1., 0., 1.); // fake cloud coverage
    return _cloud;
}

float3 getViewVec()
{
    float4 ndcPos;
    ndcPos.xy = 2.0 * gl_FragCoord.xy / camData.viewSize - 1;
    ndcPos.z = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far) / (gl_DepthRange.far - gl_DepthRange.near);
    ndcPos.w = 1.0;
    float4 clipPos = ndcPos;
    clipPos.z = 1.0;
    return normalize((inverse(camData.vmat) * inverse(camData.promat) * clipPos).xyz);
}

float2 boundaryRayTest(float3 minP, float3 maxP, float3 rayo, float3 rayd)
{
    float3 t0 = (minP - rayo) / rayd;
    float3 t1 = (maxP - rayo) / rayd;
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
    float dst0 = max(max(tmin.x, tmin.y), tmin.z);
    float dst1 = min(min(tmax.x, tmax.y), tmax.z);
    float d2b = max(0, dst0);
    float dinb = max(0, dst1 - d2b);
    return float2(d2b, dinb);
}

void main()
{
    float3 ray = getViewVec();
    float2 brt = boundaryRayTest(minPoint.xyz, maxPoint.xyz, camData.camPos, ray);
    if (brt[1] == 0)
        discard;
    float zsca = 1.0 / abs(maxPoint.z- minPoint.z);
    int n = int(floor(raySteps));
    float rayLen = brt[1] / float(n);
    float3 stepRay = ray * rayLen;
    float3 innerStepRay = -directLight.direction * rayLen;
    float3 curPos = camData.camPos + brt[0] * ray;
    float density = 0;
    for (int i = 0; i < n; i++) {
        float innerDensity = 0;
        float3 innerCurPos = curPos;
        float2 innerBrt = boundaryRayTest(minPoint.xyz, maxPoint.xyz, innerCurPos, -directLight.direction);
        if (innerBrt[1] == 0)
            continue;
        //int innerN = int(innerBrt[1] / rayLen);
        //for (int innerI = 0; innerI < innerN; innerI++) {
            innerDensity += cloudNoise(innerCurPos * zsca, frequent);
            innerCurPos += innerStepRay;
        //}
        // float4 _pos = camData.pmat * float4(curPos, 1.0);
        // float depth = _pos.z / _pos.w;
        // if (depth < gl_FragDepth)
        density += exp(-innerDensity) * (1 - exp(-innerDensity * 2));
        curPos += stepRay;
    }

    oCol = baseColor;
    oCol.a *= 1 - exp(-density);
}