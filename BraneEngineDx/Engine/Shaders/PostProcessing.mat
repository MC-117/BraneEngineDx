#material
Scalar gamma: 0.25
Scalar exposure: 3
Scalar G_SCATTERING: 0.5
Scalar fogDistance: 10
Scalar volumnicFogStep: 50
Scalar volumnicFogBlurIter: 50
Scalar bloomLightIntensity: 5
Scalar bloomDarkIntensity: 2.5
Scalar bloomThreshold: 0.7
Scalar bloomIter: 5
Scalar blurRadius: 4
Scalar blurIter: 3
Scalar blurNear: 10
Scalar blurFar: 300
Scalar blurSmoothNear: 5
Scalar blurSmoothFar: 50
Scalar blurNearIntensity: 0
Scalar blurFarIntensity: 0
Scalar ssaoRadius: 0.02
Scalar ssaoIntensity: 1.0
Scalar ssaoArea: 0.8
Scalar ssaoFalloff: 0.2
Scalar ssaoCutoff: 0.999999
Scalar ssaobias: 0
Scalar ssaoBlurIter: 10
Scalar fovDiv: 2.0
Scalar width: 1280
Scalar height: 720
Scalar lutBlend: 1.0
Scalar enableSNN: 0.0
Color volumnicLightColor: 209, 167, 102, 255
Color sunDir: 255, 0, 0, 255
Color lensFlareColor: 1.4, 1.2, 1.0, 1.0
Texture screenMap
Texture depthMap
Texture volumnicFogMap
Texture ssaoMap
Texture ssaoKernalMap
Texture LUT: defaultLut
Texture blurMap
Texture bloomMap_0
Texture bloomMap_1
Texture bloomMap_2
Texture bloomMap_3
Texture bloomMap_4
Texture bloomMap_5
Texture extraMap_0
#vertex
#version 410 core
const float2 quadVertices[4] = float2[](float2(-1.0, -1.0), float2(1.0, -1.0), float2(-1.0, 1.0), float2(1.0, 1.0));
const float2 quadUV[4] = float2[](float2(0.0, 0.0), float2(1.0, 0.0), float2(0.0, 1.0), float2(1.0, 1.0));
out float2 UV;
void main()
{
    gl_Position = float4(quadVertices[gl_VertexID], 0.0, 1.0);
    UV = quadUV[gl_VertexID];
}
#fragment
#version 410 core
layout (location = 0) out float4 oCol0;
layout (location = 1) out float4 oCol1;
in float2 UV;
uniform float3 camPos;
uniform float4 lensFlareColor;
uniform float4 sunDir;
uniform float4x4 tmat;
uniform float4x4 pmat;
uniform float4x4 promat;
uniform float4x4 vmat;
uniform float4x4 lmat;
uniform float fovy;
uniform float fovDiv;
uniform float gamma;
uniform float exposure;
uniform float4 volumnicLightColor;
uniform float G_SCATTERING;
uniform float fogDistance;
uniform float volumnicFogStep;
uniform float volumnicFogBlurIter;
uniform float bloomLightIntensity;
uniform float bloomDarkIntensity;
uniform float bloomThreshold;
uniform float bloomIter;
uniform float blurRadius;
uniform float blurIter;
uniform float blurNear;
uniform float blurFar;
uniform float blurSmoothNear;
uniform float blurSmoothFar;
uniform float blurNearIntensity;
uniform float blurFarIntensity;
uniform float ssaoRadius;
uniform float ssaoIntensity;
uniform float ssaoArea;
uniform float ssaoFalloff;
uniform float ssaoCutoff;
uniform float ssaobias;
uniform float ssaoBlurIter;
uniform float width;
uniform float height;
uniform float zNear;
uniform float zFar;
uniform float lutBlend;
uniform float enableSNN;
uniform sampler2D depthMap;
uniform sampler2D screenMap;
uniform sampler2D volumnicFogMap;
uniform sampler2D ssaoMap;
uniform sampler2D ssaoKernalMap;
uniform sampler2D LUT;
uniform sampler2D blurMap;
uniform sampler2D bloomMap_0;
uniform sampler2D bloomMap_1;
uniform sampler2D bloomMap_2;
uniform sampler2D bloomMap_3;
uniform sampler2D bloomMap_4;
uniform sampler2D bloomMap_5;
uniform sampler2D extraMap_0;
uniform int pass;

const float PI = 3.14159265359;

const float4x4 ditherPattern = float4x4(
    0.0f, 0.5f, 0.125f, 0.625f,
    0.75f, 0.22f, 0.875f, 0.375f,
    0.1875f, 0.6875f, 0.0625f, 0.5625,
    0.9375f, 0.4375f, 0.8125f, 0.3125
);

const float3 sample_sphere[16] = float3[](
    float3( 0.5381, 0.1856,-0.4319), float3( 0.1379, 0.2486, 0.4430),
    float3( 0.3371, 0.5679,-0.0057), float3(-0.6999,-0.0451,-0.0019),
    float3( 0.0689,-0.1598,-0.8547), float3( 0.0560, 0.0069,-0.1843),
    float3(-0.0146, 0.1402, 0.0762), float3( 0.0100,-0.1924,-0.0344),
    float3(-0.3577,-0.5301,-0.4358), float3(-0.3169, 0.1063, 0.0158),
    float3( 0.0103,-0.5869, 0.0046), float3(-0.0897,-0.4940, 0.3287),
    float3( 0.7119,-0.0154,-0.0918), float3(-0.0533, 0.0596,-0.5411),
    float3( 0.0352,-0.0631, 0.5460), float3(-0.4776, 0.2847,-0.0271)
);

const uint dofKernelN = 57;

const float2 dofKernel[57] = float2[](
    float2(0.000000, 0.000000),

    float2(0.461940, 0.191342), float2(0.191342, 0.461940), float2(-0.191342, 0.461940), float2(-0.461940, 0.191342),
    float2(-0.461940, -0.191342), float2(-0.191342, -0.461940), float2(0.191342, -0.461940), float2(0.461940, -0.191342),

    float2(1.000000, 0.000000), float2(0.923880, 0.382683), float2(0.707107, 0.707107), float2(0.382683, 0.923880),
    float2(0.000000, 1.000000), float2(-0.382683, 0.923880), float2(-0.707107, 0.707107), float2(-0.923880, 0.382683),
    float2(-1.000000, 0.000000), float2(-0.923880, -0.382683), float2(-0.707107, -0.707107), float2(-0.382683, -0.923880),
    float2(-0.000000, -1.000000), float2(0.382683, -0.923880), float2(0.707107, -0.707107), float2(0.923880, -0.382683),

    float2(1.492777, 0.147026), float2(1.435411, 0.435427), float2(1.322882, 0.707095), float2(1.159516, 0.951590),
    float2(0.951590, 1.159516), float2(0.707095, 1.322882), float2(0.435427, 1.435411), float2(0.147026, 1.492777),
    float2(-0.147026, 1.492777), float2(-0.435427, 1.435411), float2(-0.707095, 1.322882), float2(-0.951590, 1.159516),
    float2(-1.159516, 0.951590), float2(-1.322882, 0.707095), float2(-1.435411, 0.435427), float2(-1.492777, 0.147026),
    float2(-1.492777, -0.147026), float2(-1.435411, -0.435427), float2(-1.322882, -0.707095), float2(-1.159516, -0.951590),
    float2(-0.951590, -1.159516), float2(-0.707095, -1.322882), float2(-0.435427, -1.435411), float2(-0.147026, -1.492777),
    float2(0.147026, -1.492777), float2(0.435427, -1.435411), float2(0.707095, -1.322882), float2(0.951590, -1.159516),
    float2(1.159516, -0.951590), float2(1.322882, -0.707095), float2(1.435411, -0.435427), float2(1.492777, -0.147026)
);

float3 getRayDir() {
    float4 ndcPos;
    ndcPos.xy = 2.0 * gl_FragCoord.xy / float2(width, height) - 1;
    ndcPos.z = (2.0 * gl_FragCoord.z - zNear - zFar) / (zFar - zNear);
    ndcPos.w = 1.0;
    float4 clipPos = ndcPos;
    clipPos.z = 1.0;
    return normalize((inverse(vmat) * inverse(promat) * clipPos).xyz);
}

float computeScattering(float lightDotView)
{
    float result = 1.0 - G_SCATTERING * G_SCATTERING;
    result /= (4.0 * PI * pow(1.0 + G_SCATTERING * G_SCATTERING - (2.0 * G_SCATTERING) * lightDotView, 1.5));
    return result;
}

// float calViewZ(float2 coord) {
//     float depth = texture(depthMap, coord).x;
//     return pmat[3][2] / (2 * depth - 1 - pmat[2][2]);
// }

float3 normalFromDepth(float depth, float2 texcoords) 
{
  float2 offset1 = float2(0.0,0.0001);
  float2 offset2 = float2(0.0001,0.0);
  float2 offset3 = float2(0.0,-0.0001);
  float2 offset4 = float2(-0.0001,0.0);
  
  float depth1 = texture2D(depthMap, texcoords + offset1).r;
  float depth2 = texture2D(depthMap, texcoords + offset2).r;
  float depth3 = texture2D(depthMap, texcoords + offset3).r;
  float depth4 = texture2D(depthMap, texcoords + offset4).r;
  
  float3 p1 = float3(offset1, depth1 - depth);
  float3 p2 = float3(offset2, depth2 - depth);
  float3 p3 = float3(offset3, depth3 - depth);
  float3 p4 = float3(offset4, depth4 - depth);
  
  float3 normal1 = cross(p1, p2);
  float3 normal2 = cross(p2, p3);
  float3 normal3 = cross(p3, p4);
  float3 normal4 = cross(p4, p1);

  float3 normal = (normal1 + normal2 + normal3 + normal4) / 4;
  normal.z = -normal.z;
  
  return normalize(normal);
}

float3 reflection(float3 v1,float3 v2)
{
    float3 result= 2.0 * dot(v2, v1) * v2;
    result=v1-result;
    return result;
}

float3 lensFlare(float2 uv,float2 pos)
{
	float2 main = uv-pos;
	float2 uvd = uv*(length(uv));
	
	float ang = atan(main.x,main.y);
	float dist=length(main); dist = pow(dist,.1);
	float n = float2(ang*16.0,dist*32.0).x;
	
	float f0 = 1.0/(length(uv-pos)*16.0+1.0);
	
	f0 = f0 + f0*(sin((sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);
	
	float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;

	float f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;
	float f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;
	float f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;
	
	float2 uvx = mix(uv,uvd,-0.5);
	
	float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;
	float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;
	float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;
	
	uvx = mix(uv,uvd,-.4);
	
	float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;
	float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;
	float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;
	
	uvx = mix(uv,uvd,-0.5);
	
	float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;
	float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;
	float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;
	
	float3 c = float3(.0);
	
	c.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;
	c = c*1.3 - float3(length(uvd)*.05);
	//c+=float3(f0);
	
	return c;
}

float4 lookupTable(float4 color){
    float blueColor = color.b * 63.0;

    float2 quad1;
    quad1.y = floor(floor(blueColor) / 8.0);
    quad1.x = floor(blueColor) - (quad1.y * 8.0);
    float2 quad2;
    quad2.y = floor(ceil(blueColor) / 8.0);
    quad2.x = ceil(blueColor) - (quad2.y * 8.0);

    //ifloat2 size = textureSize(LUT, 0);

    float2 texPos1;
    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    float2 texPos2;
    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);
    float4 newColor1 = texture(LUT, texPos1);
    float4 newColor2 = texture(LUT, texPos2);
    float4 newColor = mix(newColor1, newColor2, fract(blueColor));
    return float4(newColor.rgb, color.w);
}

bool allInRange(float3 v, float3 a, float3 b)
{
    return all(lessThanEqual(a, v)) && all(lessThanEqual(v, b));
}

float4 blur13(sampler2D image, sampler2D depth, float2 uv, float2 resolution, float2 direction) {
    float4 color = float4(0.0);
    float2 off1 = float2(1.411764705882353) * direction / resolution;
    float2 off2 = float2(3.2941176470588234) * direction / resolution;
    float2 off3 = float2(5.176470588235294) * direction / resolution;

    float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv) * 0.1964825501511404;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off1).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off1) * 0.2969069646728344;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off1).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off1) * 0.2969069646728344;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off2).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off2) * 0.09447039785044732;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off2).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off2) * 0.09447039785044732;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv + off3).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv + off3) * 0.010381362401148057;

    linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depth, uv - off3).r - 1.0) * (zFar - zNear));
    if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar)
        color += texture2D(image, uv - off3) * 0.010381362401148057;
    return color;
}

float CalcDistance(in float3 c0, in float3 c1) {
    float3 sub = c0 - c1;
    return dot(sub, sub);
}

// Symmetric Nearest Neighbor
float4 CalcSNN(in sampler2D iChannel0, in float2 src_size, in float2 uv) {
    float3 c0 = texture(iChannel0, uv).rgb;

    float m0 = texture(extraMap_0, uv).r;
    if (m0 != 1)
        return float4(c0, 1);

    float2 inv_src_size = 1.0f / src_size;

    int half_width = 5;
    
    float4 sum = float4(0.0f, 0.0f, 0.0f, 0.0f);
    
    for (int i = 0; i <= half_width; ++i) {
        float2 uv1 = uv + float2(+i, 0) * inv_src_size;
        float2 uv2 = uv + float2(-i, 0) * inv_src_size;
        float m1 = texture(extraMap_0, uv1).r;
        float m2 = texture(extraMap_0, uv2).r;
        if (m1 != 1 && m2 != 1) {
            continue;
        }
        else if (m1 == 1 && m2 != 1) {
            float3 c = texture(iChannel0, uv1).rgb;
            sum.rgb += c;
        }
        else if (m1 != 1 && m2 == 1) {
            float3 c = texture(iChannel0, uv2).rgb;
            sum.rgb += c;
        }
        else {
            float3 c1 = texture(iChannel0, uv1).rgb;
            float3 c2 = texture(iChannel0, uv2).rgb;
            
            float d1 = CalcDistance(c1, c0);
            float d2 = CalcDistance(c2, c0);
            if (d1 < d2) {
                sum.rgb += c1;
            } else {
                sum.rgb += c2;
            }
        }
        sum.a += 1.0f;
    }
 	for (int j = 1; j <= half_width; ++j) {
    	for (int i = -half_width; i <= half_width; ++i) {
            float2 uv1 = uv + float2(+i, +j) * inv_src_size;
            float2 uv2 = uv + float2(-i, -j) * inv_src_size;
            float m1 = texture(extraMap_0, uv1).r;
            float m2 = texture(extraMap_0, uv2).r;
            if (m1 != 1 && m2 != 1) {
                continue;
            }
            else if (m1 == 1 && m2 != 1) {
                float3 c = texture(iChannel0, uv1).rgb;
                sum.rgb += c;
            }
            else if (m1 != 1 && m2 == 1) {
                float3 c = texture(iChannel0, uv2).rgb;
                sum.rgb += c;
            }
            else {
                float3 c1 = texture(iChannel0, uv1).rgb;
                float3 c2 = texture(iChannel0, uv2).rgb;
                
                float d1 = CalcDistance(c1, c0);
                float d2 = CalcDistance(c2, c0);
                if (d1 < d2) {
                    sum.rgb += c1;
                } else {
                    sum.rgb += c2;
                }
            }
            sum.a += 1.0f;
		}
    }
    return sum / sum.a;
}

void main()
{
    if (pass == 0) {
        float3 rayDir = getRayDir();
        //float3 sunDir = normalize((lmat * float4(1.0, 0, 0, 1.0)).xyz);
        float3 step = rayDir * (fogDistance / floor(volumnicFogStep));
        float3 curPos = camPos + step;//(ditherPattern * float4(step, 1.0)).xyz;
        float fog = 0;
        for (int i = 0; i < volumnicFogStep; i++) {
            float4 fragPosLightSpace = lmat * float4(curPos, 1.0);
            float3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
            projCoords = projCoords * 0.5 + 0.5;
            if (projCoords.z > 1.0)
                continue;
            float depthVal = texture(depthMap, projCoords.xy).r;
            if (depthVal > projCoords.z ) {
                fog += computeScattering(dot(rayDir, sunDir.xyz));
            }
            else
                break;
            curPos += step;
        }
        fog /= floor(volumnicFogStep);
        oCol0 = volumnicLightColor * fog;
        oCol0.a = 1.0;
    }
    else if (pass == 1) {
        float4 c = float4(0);
        int n = clamp(int(volumnicFogBlurIter), 0, 30);
        float volumnicFogOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - float2(0, volumnicFogOffset / height * i));
            c += texture(screenMap, UV + float2(0, volumnicFogOffset / height * i));
        }
        oCol0 = c / (floor(volumnicFogBlurIter) * 2.0);
        oCol0.a = 1.0;
    }
    else if (pass == 2) {
        float4 f = float4(0);
        int n = clamp(int(volumnicFogBlurIter), 0, 30);
        float volumnicFogOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            f += texture(volumnicFogMap, UV - float2(volumnicFogOffset / width * i, 0));
            f += texture(volumnicFogMap, UV + float2(volumnicFogOffset / width * i, 0));
        }
        float3 fog = f.xyz / (floor(volumnicFogBlurIter) * 2.0);
        float3 col = fog + float3(texture(screenMap, UV)) * texture(ssaoMap, UV).r;
        oCol0 = float4(col, 1.0);
        float3 rate = smoothstep(bloomThreshold, bloomThreshold + 0.1, col) * col - float3(bloomThreshold);
        oCol1.rgb = mix(bloomDarkIntensity * col, bloomLightIntensity * col, rate);
        oCol1.a = 1.0;
    }
    else if (pass == 3) {
        float4 c = texture(screenMap, UV);
        c.rgb = float3(1.0) - exp(-c.rgb * exposure);
        c.rgb = pow(c.rgb, float3(1.0/gamma));
        oCol0 = c;
        oCol0.a = 1.0;
    }
    else if (pass == 4) {
        float4 c = float4(0);
        int n = clamp(int(bloomIter), 0, 30);
        float bloomOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - float2(0, bloomOffset / height * i));
            c += texture(screenMap, UV + float2(0, bloomOffset / height * i));
        }
        oCol0.rgb = (c / (n * 2.0)).rgb;
        oCol0.a = 1.0;
    }
    else if (pass == 5) {
        float4 c = float4(0);
        int n = clamp(int(bloomIter), 0, 30);
        float bloomOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(screenMap, UV - float2(bloomOffset / width * i, 0));
            c += texture(screenMap, UV + float2(bloomOffset / width * i, 0));
        }
        oCol0.rgb = (c / (n * 2.0)).rgb;
        oCol0.a = 1.0;
    }
    else if (pass == 6) {
        //float4 c = texture(bloomMap_0, UV);
        float4 c = texture(screenMap, UV) +
                 texture(bloomMap_0, UV) +
                 texture(bloomMap_1, UV) * 0.9 +
                 texture(bloomMap_2, UV) * 0.8 +
                 texture(bloomMap_3, UV) * 0.7 +
                 texture(bloomMap_4, UV) * 0.6 +
                 texture(bloomMap_5, UV) * 0.5;
        //c = clamp(c, 0.0, 1.0);
        c.rgb = float3(1.0) - exp(-c.rgb * exposure);
        c.rgb = pow(c.rgb, float3(1.0/gamma));
        oCol0 = c;
        oCol0.a = 1.0;
    }
    else if (pass == 7) {
    //     float4 c = float4(0);
    //     int n = int(blurIter);
    //    // float b2 = blurIter * blurIter;
    //     float blurOffset = n / 400.0;
    //     float weight = 0;
    //     float4 cc = texture(screenMap, UV);// * (n - i);
    //     float w = length(cc.rgb) + 0.1;
    //     weight += w;
    //     c += cc * w;
        // for (int i = 1; i < n; i++) {
        //     float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - float2(0, i / height)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap, UV - float2(0, i / height));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        //     linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + float2(0, i / height)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap, UV + float2(0, i / height));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        // }
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         if ((i == 0 && j != 0) || (i != 0 && j == 0))
        //             continue;
        //         if ((i * i + j * j) >= n * n )
        //             continue;
        //         float2 off = float2(i / width, j / height);
        //         float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         off.x *= -1;
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //     }
        // }
        float weight = 0;
        float3 c = float3(0);
        int n = blurIter < 1 ? 1 : (blurIter < 2 ? 9 : (blurIter < 3 ? 25 : 57));
        for (int i = 0; i < n; i++) {
            float2 off = dofKernel[i] * blurRadius;
            off.x /= width;
            off.y /= height;
            float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
            float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) +
                smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth);
            if (rate != 0) {
                float3 cc = texture(screenMap, UV + off * rate).rgb;
                float w = length(cc) + 0.1;
                weight += w;
                c += cc * w;
            }
        }
        oCol0.rgb = c / weight;//((1 + n) * n);
        oCol0.a = 1.0;
    }
    else if (pass == 8) {
        // float4 c = float4(0);
        // int n = int(blurIter);
        // //float b2 = blurIter * blurIter;
        // float blurOffset = n / 400.0;
        // float weight = 0;
        // float4 cc = texture(screenMap, UV);// * (n - i);
        // float w = length(cc.rgb) + 0.1;
        // weight += w;
        // c += cc * w;
        // for (int i = 1; i < n; i++) {
        //     float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap,  UV - float2(i / width, 0)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap,  UV - float2(i / width, 0));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        //     linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap,  UV + float2(i / width, 0)).r - 1.0) * (zFar - zNear));
        //     if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //         cc = texture(screenMap,  UV + float2(i / width, 0));// * (n - i);
        //         w = length(cc.rgb) + 0.1;
        //         weight += w;
        //         c += cc * w;
        //     }
        // }
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         if ((i * i + j * j) >= n * n )
        //             continue;
        //         float2 off = float2((i + n / 2) / width, (j + n / 2) / height);
        //         float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         off.x *= -1;
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV - off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV - off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //         linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV + off).r - 1.0) * (zFar - zNear));
        //         if (linearDepth <= blurNear + blurSmoothNear || linearDepth >= blurFar - blurSmoothFar) {
        //             cc = texture(screenMap, UV + off);// * (n - i);
        //             w = length(cc.rgb) + 0.1;
        //             weight += w;
        //             c += cc * w;
        //         }
        //     }
        // }
        oCol0.rgb = texture(screenMap, UV).rgb;//c.rgb / weight;//((1 + n) * n);
        oCol0.a = 1.0;
    }
    else if (pass == 9) {
        float linearDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * texture(depthMap, UV).r - 1.0) * (zFar - zNear));
        float4 blurC = texture(blurMap, UV);
        float4 screenC = CalcSNN(screenMap, float2(width, height), UV);//enableSNN == 0 ? texture(screenMap, UV) : CalcSNN(screenMap, float2(width, height), UV);
        float rate = (1 - smoothstep(blurNear, blurNear + blurSmoothNear, linearDepth)) * blurNearIntensity +
            smoothstep(blurFar - blurSmoothFar, blurFar, linearDepth) * blurFarIntensity;
        // float rate = (linearDepth <= (blurNear + blurSmoothNear) ? 1 : 0) * blurNearIntensity +
        //     (linearDepth >= (blurFar - blurSmoothFar) ? 1 : 0) * blurFarIntensity;
        oCol0 = mix(screenC, blurC, rate);
        float aspect = float(height) / float(width);
        float4 sunPos = promat * vmat * float4(camPos + sunDir.xyz, 1.0);
        sunPos /= sunPos.w;
        float2 viewSca = float2(1) - pow(sunPos.xy, float2(2));
        if (all(greaterThan(viewSca, float2(0)))) {
            float3 flare = lensFlare((UV - float2(0.5)) * float2(1, aspect) * 2.0, sunPos.xy * float2(1, aspect)) * lensFlareColor.rgb * abs(viewSca.x * viewSca.y);
            oCol0.xyz = mix(oCol0.xyz, flare, flare);
        }
        oCol0 = mix(oCol0, tan(lookupTable(atan(oCol0) * (2.0 / PI)) * (PI / 2.0)), lutBlend);
        oCol0.a = 1;
    }
    else if (pass == 10) {
        // float3 pos = reconstructPos();
        // float AO = 0.0;

        // for (int i = 0 ; i < 16 ; i++) {
        //     float3 samplePos = pos + ssaoKernal[i];
        //     float4 offset = float4(samplePos, 1.0);
        //     offset = pmat * offset;
        //     offset.xy /= offset.w;
        //     offset.xy = offset.xy * 0.5 + 0.5;

        //     float sampleDepth = calViewZ(offset.xy);

        //     // float rangeCheck = smoothstep(0.0, 1.0, ssaoRadius / abs(pos.z - sampleDepth));
        //     // AO += (sampleDepth >= samplePos.z ? 1.0 : 0.0) * rangeCheck;

        //     if (abs(pos.z - sampleDepth) < ssaoRadius) {
        //         AO += step(sampleDepth,samplePos.z);
        //     }
        // }
        // AO = 1.0 - AO / 16.0;
        // oCol0.rgb = float3(AO * AO);
        // oCol0.a = 1.0;
        float depth = texture2D(depthMap, UV).r;
        float3 normal = normalFromDepth(depth, UV);
        if (depth < ssaoCutoff && abs(dot(normal, float3(0, 0, 1))) < (1 - ssaobias)) {
            float3 random = normalize(texture2D(ssaoKernalMap, UV * 8.0).rgb);
            float3 position = float3(UV.x,UV.y,depth);
            float radiusDepth = ssaoRadius/depth;
            float occlusion = 0.0;
            //float bias = max(ssaobias * dot(normal, float3(0, 0, 1)), ssaobias * 0.1);

            int iterations = 16;
            for (int j = 0; j < iterations; ++j)
            {
                float3 ray = radiusDepth * reflection(sample_sphere[j], random);
                if (dot(ray,normal) > 0) {
                    float3 hemiRay = position + ray;
                
                    float occDepth = texture2D(depthMap, clamp(hemiRay.xy,0.0,1.0)).r;
                    float difference = depth - occDepth;

                    occlusion += smoothstep(ssaoFalloff, ssaoArea, (depth >= occDepth ? 1.0 : 0.0) * (1 - smoothstep(0, 1, abs(difference) / ssaoRadius)));
                }
                //occlusion += step(ssaoFalloff, difference) * smoothstep(ssaoFalloff, ssaoArea, difference);
            }

            float ao = occlusion * (1.0 / iterations);
            ao = smoothstep(ssaoFalloff, ssaoArea, ao) * ssaoIntensity * ao;
            ao = 1 - ao;
            float final = clamp(ao * ao,0.0,1.0);

            oCol0 = float4(final,final,final,1);
        }
        else
            oCol0 = float4(1);
    }
    if (pass == 11) {
        float4 c = float4(0);
        int n = clamp(int(ssaoBlurIter), 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - float2(0, ssaoOffset / height * i));
            c += texture(ssaoMap, UV + float2(0, ssaoOffset / height * i));
        }
        oCol0 = c / (n * 2.0);
        oCol0.a = 1.0;
    }
    if (pass == 12) {
        float4 c = float4(0);
        int n = clamp(int(ssaoBlurIter), 0, 30);
        float ssaoOffset = -0.02 * n + 0.6;
        for (int i = 0; i < n; i++) {
            c += texture(ssaoMap, UV - float2(ssaoOffset / width * i, 0));
            c += texture(ssaoMap, UV + float2(ssaoOffset / width * i, 0));
        }
        oCol0 = c / (n * 2.0);
        oCol0.a = 1.0;
    }
}