#adapter name particle
#vertex particle
#version 460 core
#include "../lib/ParticleData_Def.hmat"

out Particle gParticle;
out uint index;

void main()
{
    index = gl_InstanceID + gl_BaseInstance;
    gParticle = Particles[index];
    //gl_Position = float4(gParticle.pos, 1.0);
}

#geometry particle
#version 460 core
#include "../lib/ParticleData_Def.hmat"
#include "../lib/CameraData_Def.hmat"

layout (points) in;
layout (triangle_strip, max_vertices = 4) out;
in Particle gParticle[];
in uint index[];
uniform float uvScale;
out Particle particle;
out float2 UV;

float3 lineCross(float3 a1, float3 b1, float3 a2, float3 b2)
{
    float3 p1 = a1, p2 = a2;
    float3 d1 = b1 - a1, d2 = b2 - a2;
    float3 ans1, ans2;
    float t1, t2;
    t1 = dot((cross(p2 - p1, d2)), cross(d1, d2));
    t2 = dot((cross(p2 - p1, d1)), cross(d1, d2));
    float dd = length((cross(d1, d2)));
    t1 /= dd * dd;
    t2 /= dd * dd;
    ans1 = (a1 + (b1 - a1) * t1);
    ans2 = (a2 + (b2 - a2) * t2);
    return (ans1 + ans2) / 2.0;
}

float3 calH(uint i)
{
    if (i == 0 && Particles[i].extSca == 1)
        return float3(0, 0, 0);
    if (i == 0) {
        float3 v = Particles[i + 1].pos - Particles[i].pos;
        return normalize(cross(v, Particles[i].pos - camData.camPos)) * Particles[i].scale.x;
    }
    else if (Particles[i].extSca == 1) {
        float3 v = Particles[i].pos - Particles[i - 1].pos;
        return normalize(cross(v, Particles[i].pos - camData.camPos)) * Particles[i].scale.x;
    }
    else {
        float3 v0 = Particles[i].pos - Particles[i - 1].pos;
        float3 v1 = Particles[i + 1].pos - Particles[i].pos;
        float3 cv0 = (Particles[i - 1].pos + Particles[i].pos) / 2.0 - camData.camPos;
        float3 cv1 = (Particles[i].pos + Particles[i + 1].pos) / 2.0 - camData.camPos;
        float3 v = normalize(v0) + normalize(v1);
        float3 cv = normalize(cv0) + normalize(cv1);
        return normalize(cross(v, cv)) * Particles[i].scale.x;
    }
}

void main()
{
    particle = gParticle[0];
    float3 v;
    float3 h0, h1;
    float3 pos0, pos1;

    if (particle.type == 0) {
        v = camData.camUp * particle.scale.y * 0.5;
        h0 = h1 = camData.camLeft * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 1) {
        v = normalize(particle.velocity) * particle.scale.y * 0.5;
        h0 = h1 = normalize(cross(particle.velocity, particle.pos - camData.camPos)) * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 2) {
        v = (particle.extVec.xyz - particle.pos) * particle.scale.y * (particle.maxLifetime == 0 ?
        1 : clamp((1 - particle.lifetime / particle.maxLifetime) / particle.extVec.w, 0, 1));
        h0 = h1 = normalize(cross(v, particle.pos - camData.camPos)) * particle.scale.x * 0.5;
        pos0 = particle.pos;
        pos1 = particle.pos + v;
    }
    else if (particle.type == 3) {
        if (Particles[index[0]].extSca == 1)
            return;
        h0 = calH(index[0]);
        h1 = calH(index[0] + 1);
        pos0 = particle.pos;
        pos1 = Particles[index[0] + 1].pos;
    }
    else {
        v = camData.camUp * particle.scale.y * 0.5;
        h0 = h1 = camData.camLeft * particle.scale.x * 0.5;
        pos0 = particle.pos - v;
        pos1 = particle.pos + v;
    }

    float uvS = uvScale == 0 ? 1 : (uvScale * length(pos1 - pos0) / length(h0 + h1) * 2.0);

    gl_Position = camData.pmat * float4(pos0 + h0, 1.0);
    UV = float2(0, 0);
    EmitVertex();

    gl_Position = camData.pmat * float4(pos0 - h0, 1.0);
    UV = float2(1, 0);
    EmitVertex();

    gl_Position = camData.pmat * float4(pos1 + h1, 1.0);
    UV = float2(0, uvS);
    EmitVertex();

    gl_Position = camData.pmat * float4(pos1 - h1, 1.0);
    UV = float2(1, uvS);
    EmitVertex();

    EndPrimitive();
}