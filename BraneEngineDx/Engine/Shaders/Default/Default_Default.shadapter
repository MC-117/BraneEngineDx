#adapter name default
#vertex
#version 460 core
#include "../lib/TransformData_def.hmat"
#include "../lib/CameraData_Def.hmat"
#include "../lib/Light_Def.hmat"
#include "../lib/MeshData_Def.hmat"

out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

void main()
{
    float4x4 fm = Transforms[ObjectIDs[gl_InstanceID + gl_BaseInstance]];
    float4 _WorldPos = fm * float4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}
#vertex skeleton
#version 460 core
#include "../lib/TransformData_def.hmat"
#include "../lib/CameraData_Def.hmat"
#include "../lib/Light_Def.hmat"
#include "../lib/SkeletonMeshData_Def.hmat"

out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

float4x4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    float4x4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}

void main()
{
    float4x4 fm = getFinalMat();
    float4 _WorldPos = fm * float4(pos, 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * norm);
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}
#vertex skeleton morph
#version 460 core
#include "../lib/TransformData_def.hmat"
#include "../lib/CameraData_Def.hmat"
#include "../lib/Light_Def.hmat"
#include "../lib/SkeletonMeshData_Def.hmat"
#include "../lib/MorphData_def.hmat"

out float3 Normal;
out float2 TexCoords;
out float4 lightSpacePos;
out float3 WorldPos;

float3 morphPos()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    float3 w = float3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2].xyz * morphWeight[i];
    }
    return pos + w;
}

float3 morphNorm()
{
    uint nMorph = uint(nMorphV);
    uint base = gl_VertexID * nMorph;
    float3 w = float3(0, 0, 0);
    for (uint i = 0; i < nMorph; i++) {
        w += morphData[(base + i) * 2 + 1].xyz * morphWeight[i];
    }
    return norm + w;
}

float4x4 getFinalMat()
{
    float tw = weights[0] + weights[1] + weights[2] + weights[3];
    uint bid = ObjectIDs[gl_InstanceID + gl_BaseInstance];
    float4x4 fm = Transforms[bid + boneId[0]] * weights[0] / tw;
    if (weights[1] != 0)
        fm += Transforms[bid + boneId[1]] * weights[1] / tw;
    if (weights[2] != 0)
        fm += Transforms[bid + boneId[2]] * weights[2] / tw;
    if (weights[3] != 0)
        fm += Transforms[bid + boneId[3]] * weights[3] / tw;
    return fm;
}

void main()
{
    float4x4 fm = getFinalMat();
    float4 _WorldPos = fm * float4(morphPos(), 1.0);
    WorldPos = _WorldPos.xyz;
    gl_Position = camData.pmat * _WorldPos;
    Normal = normalize(float3x3(fm) * morphNorm());
    lightSpacePos = directLight.lmat * _WorldPos;
    TexCoords = uv;
    TexCoords.y = 1 - TexCoords.y;
}