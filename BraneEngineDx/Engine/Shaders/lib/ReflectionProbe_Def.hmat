#include "Basic_FS_Lib.hmat"

struct ReflectionProbeData
{
	float4 tintColor;
	float3 position;
	float radius;
	float falloff;
	float cutoff;
	int cubeMapIndex;
	int reverseIndex;
};

StructuredBuffer<ReflectionProbeData> reflectionProbes : register(RELFECTION_PROBE_BIND_INDEX);
TextureCubeArray reflectionCubeMap : register(t3);
SamplerState reflectionCubeMapSampler : register(s3);

#define REFLECTION_CAPTURE_ROUGHEST_MIP 1
#define REFLECTION_CAPTURE_ROUGHNESS_MIP_SCALE 1.2

float getReflectionMip(float roughness)
{
	uint mipLevels = getLodLevels(reflectionCubeMap) - 1;
	float levelFrom1x1 = REFLECTION_CAPTURE_ROUGHEST_MIP - REFLECTION_CAPTURE_ROUGHNESS_MIP_SCALE * log2(max(roughness, 0.001));
	return mipLevels - 1 - levelFrom1x1;
}

float4 getReflectionColor(float3 L, float3 worldPos, float mipLevel = 0.0f)
{
	uint count, stride;
	reflectionProbes.GetDimensions(count, stride);
	float minDis = 10000000;
	float4 color = float4(0, 0, 0, 0);
	float weightSum = 0;
	for (int i = 0; i < count; i++) {
		ReflectionProbeData data = reflectionProbes[i];
		if (data.cubeMapIndex >= 0) {
			float dis = distance(data.position, worldPos);
			float weight = 1 - dis / data.radius;
			if (weight > 0.0001) {
				float4 sampleColor = SAMPLE_TEX_LOD(reflectionCubeMap, float4(L, data.cubeMapIndex), mipLevel);
				color += sampleColor * weight * smoothstep(data.cutoff, data.falloff, data.radius - dis) * data.tintColor;
				weightSum += weight;
			}
		}
		if (data.reverseIndex == 0)
			break;
	}
	color *= rcp(weightSum);
	return max(0, color);
}