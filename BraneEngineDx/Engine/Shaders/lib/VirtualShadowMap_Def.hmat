#include "Basic_FS_Lib.hmat"
#include "TransformData_Def.hmat"

#define VSM_DirectLight 0
#define VSM_LocalLight 1

// Used in the PageFlags
// NOTE: These flags are combined hierarchically using bitwise *OR*, so plan/negate them appropriately
// Marks pages that are allocated
#define VSM_ALLOCATED_FLAG			(1U << 0)
// Marks pages whose dynamic pages are uncached
#define VSM_DYNAMIC_UNCACHED_FLAG	(1U << 1)
// Marks pages whose static pages are uncached
#define VSM_STATIC_UNCACHED_FLAG	(1U << 2)
// Marks pages that are _not_ coarse (i.e., "normal" pages) that should include all geometry and conversely to mark geometry that is 
// "detail geometry" and which can skip rendering to coarse pages
#define VSM_DETAIL_GEOMETRY_FLAG	(1U << 3)

// Stored in the physical meta data flags and must be higher than the  VSM_*_FLAG
// The light was marked to not be cached (even though caching is enabled)
#define VSM_PHYSICAL_FLAG_VIEW_UNCACHED		(1U << 4) 
#define VSM_PHYSICAL_FLAG_DIRTY				(1U << 5) 


// bit-offset for storing another set of page flags used to track invalidation in the physical page metadata flags.
#define VSM_PHYSICAL_PAGE_INVALIDATION_FLAGS_SHIFT 8U

// NOTE: Bits for the hierarchical page flags are stored in the same uints as the regular mip tail,
// offset based on the Hmip level. For instance, at the 1x1 level the first 4 bits store the page
// flags for the coarsest mip, the next 4 bits store the hierarchical page flags for the second
// coarsest mip and so on.
// If the total bit count needs to change be sure it doesn't overlow the page flags for all Hmips
#define VSM_PAGE_FLAGS_BITS_PER_HMIP (4U)
#define VSM_PAGE_FLAGS_BITS_MASK     ((1U<<VSM_PAGE_FLAGS_BITS_PER_HMIP)-1U)

#define VSM_PAGE_SIZE 128U
#define VSM_LOG2_PAGE_SIZE ((uint)log2(VSM_PAGE_SIZE))
#define VSM_L0_PAGES 128U
#define VSM_LOG2_L0_PAGES  ((uint)log2(VSM_L0_PAGES))
#define VSM_MAX_MIPS (VSM_LOG2_L0_PAGES + 1)
#define VSM_MAX_SIZE (VSM_PAGE_SIZE * VSM_L0_PAGES)

#define NONE_VSMID -1

// Log2 2D dimension of thread group size, 2^4 == 16, 
#define LOG2_TILE_THREAD_GROUP_SIZE_XY 4U
#define TILE_THREAD_GROUP_SIZE_XY (1U << LOG2_TILE_THREAD_GROUP_SIZE_XY)

// Each thread takes 2x2 samples to work with, so tile size is 2x thread group size
#define LOG2_TILE_SIZE_XY (LOG2_TILE_THREAD_GROUP_SIZE_XY + 1U)

// Number of tiles (thread groups) in each dimension to cover the page
#define LOG2_TILES_PER_PAGE_XY ( VSM_LOG2_PAGE_SIZE - LOG2_TILE_SIZE_XY )
// Log2 1D tile count to cover the page  LOG2_TILES_PER_PAGE_XY * LOG2_TILES_PER_PAGE_XY
#define LOG2_TILES_PER_PAGE_1D ( 2U * LOG2_TILES_PER_PAGE_XY )
// 1D tile count to cover the page  
#define TILES_PER_PAGE_1D ( 1U << LOG2_TILES_PER_PAGE_1D )

#define TILES_PER_PAGE_XY_MASK ( ( 1U << LOG2_TILES_PER_PAGE_XY ) - 1U )
#define TILES_PER_PAGE_1D_MASK ( ( 1U << LOG2_TILES_PER_PAGE_1D ) - 1U )

uint calcLevelOffsets(uint Level)
{
	// VSM_LOG2_L0_PAGES is a power of two, so the footprint of each mip level MipSize_i=(VSM_LOG2_L0_PAGES>>i)^2 is also a power of two.
	// The binary representation of a mip size is just a single bit: 1 << log2(MipSize_i) = (1 << (2 * (VSM_LOG2_L0_PAGES - i))).
	
	// To calculate the offset we need to calculate a sum of consecutive mip sizes, which is equivalent to producing a bit pattern with one bit per level starting out at 
	// bitposition 2*VSM_LOG2_L0_PAGES and going down by 2 for every level.
	// E.g. VSM_LOG2_L0_PAGES=3
	//   Level 0: 0000000
	//   Level 1: 1000000
	//   Level 2: 1010000
	//   Level 3: 1010100
	//   Level 4: 1010101

	// To quickly produce a variable number of bits we just select a range of bits from the alternating bit sequence 0x55=0b01010101.
	uint NumBits = Level << 1;
	uint StartBit = (2 * VSM_LOG2_L0_PAGES + 2) - NumBits;
	uint Mask = ((1u << NumBits) - 1u) << StartBit;

	return 0x55555555u & Mask;
}

#define VSM_PAGE_TABLE_SIZE (calcLevelOffsets(VSM_LOG2_L0_PAGES))

uint calcLog2LevelPages(uint level)
{
	return VSM_LOG2_L0_PAGES - level;	// log2( VSM_LOG2_L0_PAGES >> level )
}

uint calcLevelPages(uint level)
{
	return 1u << calcLog2LevelPages(level);
}

uint calcPageTableLevelOffset(uint vsmID, uint level)
{
	return vsmID * VSM_PAGE_TABLE_SIZE + calcLevelOffsets(level);
}

uint calcPageOffsetInLevel(uint level, uint2 pageAddress)
{
	return pageAddress.x + ( pageAddress.y << calcLog2LevelPages(level) );
}

uint calcPageOffset(uint vsmID, uint level, uint2 pageAddress)
{
	return calcPageTableLevelOffset(vsmID, level) + calcPageOffsetInLevel(level, pageAddress);
}

int calcMipLevel(int4 rect, int coveredPixels)
{
    const int maxPixelOffset = coveredPixels - 1;
	const int mipOffset = (int)log2((float)coveredPixels) - 1;

    int2 mipLevelXY = firstbithigh(rect.zw - rect.xy);

	int mipLevel = max(max(mipLevelXY.x, mipLevelXY.y) - mipOffset, 0);

	mipLevel += any((rect.zw >> mipLevel) - (rect.xy >> mipLevel) > maxPixelOffset) ? 1 : 0;

	return mipLevel;
}

struct VSMProjData
{
	float4x4 worldToView;
	float4x4 viewToClip;
	float4x4 worldToClip;
	float4x4 worldToUV;

	float3 clipmapWorldOrigin;
	int resolutionLodBias;
	
	int2 clipmapOffset;
	int clipmapIndex;
	int clipmapLevel;

	int clipmapCount;

	int vsmID;

	int lightType;

	int uncached;

};

struct VSMInfo
{
	uint physPageRowMask;
	uint physPageRowShift;
	uint maxPhysPages;
	uint numShadowMapSlots;
	uint2 physPoolSize;
	uint2 physPoolPages;
};

tbuffer VSMInfoBuff
{
	VSMInfo vsmInfo;
};

struct VSMPrevData
{
	int vsmID;
	int2 clipmapCornerOffsetDelta;
	int pad;
};

struct ScreenRect
{
    int4 pixels;
    int4 hzbTexels;
    int hzbLevel;
    int depth;
};

struct FrustumCullData
{
    float3 rectMin;
    bool visiable;
    float3 rectMax;
};

FrustumCullData frustumCullBoxOrtho(float3 center, float3 extent, float4x4 localToWorld, float4x4 worldToClip)
{
    FrustumCullData data;
    float3 centerClip = mul( mul( float4( center, 1 ), localToWorld ), worldToClip ).xyz;

	float3 clipDelta =
        abs( extent.x * mul(localToWorld[0], worldToClip).xyz ) +
        abs( extent.y * mul(localToWorld[1], worldToClip).xyz ) +
        abs( extent.z * mul(localToWorld[2], worldToClip).xyz );

	data.rectMin = centerClip - clipDelta;
	data.rectMax = centerClip + clipDelta;

    data.visiable = data.rectMax.z > 0.0f && !any(
        (data.rectMax.xy < -1.0f) || (data.rectMin.xy > 1.0f));
    return data;
}

ScreenRect getScreenRect(int4 viewRect, FrustumCullData cullData, int coveredPixels)
{
    ScreenRect rect;
    rect.depth = cullData.rectMax.z;
    float4 rectUV = saturate(float4(cullData.rectMin.xy, cullData.rectMax.xy) *
        float2(0.5, -0.5).xyxy + 0.5).xwzy;
    float2 viewSize = viewRect.zw - viewRect.xy;
	rect.pixels = int4( rectUV * viewSize.xyxy + viewRect.xyxy +
        float4(0.5f, 0.5f, -0.5f, -0.5f));
	rect.pixels.xy = max(rect.pixels.xy, viewRect.xy);
	rect.pixels.zw = min(rect.pixels.zw, viewRect.zw - 1);

    rect.hzbTexels = int4(rect.pixels.xy, max(rect.pixels.xy, rect.pixels.zw));	
    rect.hzbTexels = rect.hzbTexels >> 1;

    rect.hzbLevel = calcMipLevel(rect.hzbTexels, coveredPixels);

	rect.hzbTexels >>= rect.hzbLevel;

	return rect;
}

float calcAbsClipmapLevel(VSMProjData baseProjData, float3 worldPos)
{
	float distToClipmapOrigin = length(worldPos - baseProjData.clipmapWorldOrigin);
	return log2(distToClipmapOrigin);
}

int calcClipmapLevel(VSMProjData baseProjData, float3 worldPos)
{
	float biasedLevel = calcAbsClipmapLevel(baseProjData, worldPos) + baseProjData.resolutionLodBias;
	return int(floor(biasedLevel));
}

struct VSMPhysPageMetaData
{
	uint flags;
	uint age;
	uint virtualPageOffset;
	uint vsmID;
};

struct VSMPhysPageRequest
{
	uint vsmID;
	uint globalPageOffset;
};

// Current page table format:
// NOTE: Some redundancy in flags and encoding, but we have spare bits for now
//   [0:9] PageAddress.x
//   [10:19] PageAddress.y
//   [20:25] LODOffset
//   [26:30] (currently unused)
//   [31] bAnyLODValid
struct VSMPhysPage
{
	uint2 physAddress;	// Physical page address X, Y
	uint lodOffset;			// 0 if page is mapped at this mip/clipmap level; 1 if mapped at next courser level, etc. [0..64)
	bool isAnyLODValid;		// Valid physical page mapped at some LOD level
	bool isThisLODValid;		// Valid page mapped at this specific level (equivalent to bAnyMipValid && LODOffset == 0)
};

#define VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG 0x8000000
#define VSM_PHYSICAL_PAGE_INVALID 0x00000000

uint vsmEncodePageTable(uint2 physAddress)
{
	return VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG | (physAddress.y << 10) | (physAddress.x);
}
uint vsmEncodePageTable(uint2 physAddress, uint lodOffset)
{
	return VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG | (lodOffset << 20) | (physAddress.y << 10) | (physAddress.x);
}

VSMPhysPage vsmDecodePageTable(uint value)
{
	VSMPhysPage res;
	res.physAddress = uint2(value & 0x3FF, (value >> 10) & 0x3FF);
	res.lodOffset = (value >> 20) & 0x3F;
	res.isAnyLODValid = (value & VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG) != 0;
	res.isThisLODValid = res.isAnyLODValid && res.lodOffset == 0;
	return res;
}

uint physPageAddressToIndex(uint2 physPageAddress)
{
	return (physPageAddress.y << vsmInfo.physPageRowShift) + physPageAddress.x;
}

uint2 physIndexToPageAddress(uint pageIndex)
{
	uint2 pageAddress;
	pageAddress.x = pageIndex  & vsmInfo.physPageRowMask;
	pageAddress.y = pageIndex >> vsmInfo.physPageRowShift;
	return pageAddress;
}

void calcPageAddressFromIndex(uint index, inout uint mipLevel, inout uint2 pageAddress)
{
	pageAddress = uint2(0xFFFFFFFF, 0xFFFFFFFF);

	// TODO: There is probably some clever math we can use for this instead;
	// See CalcLevelOffsets for a start
	for (mipLevel = 0; mipLevel < VSM_MAX_MIPS - 1; ++mipLevel)
	{
		if (index < calcLevelOffsets(mipLevel + 1))
		{
			break;
		}
	}
	const uint level0RowMask = ((1U << VSM_LOG2_L0_PAGES) - 1U);
	const uint offsetInLevel = index - calcLevelOffsets(mipLevel);
	pageAddress.x = offsetInLevel & (level0RowMask >> mipLevel);
	pageAddress.y = offsetInLevel >> (VSM_LOG2_L0_PAGES - mipLevel);
}

StructuredBuffer<uint> pageTable;
StructuredBuffer<uint> pageFlags;
StructuredBuffer<VSMPhysPageMetaData> physPageMetaData;
StructuredBuffer<VSMProjData> projData;
StructuredBuffer<uint> pageRequestFlags;
StructuredBuffer<uint4> pageRect;
StructuredBuffer<uint> freePhysPages;
StructuredBuffer<VSMPhysPageRequest> physPageAllocRequests;
StructuredBuffer<uint4> allocPageRect;

StructuredBuffer<VSMPrevData> vsmPrevData;
StructuredBuffer<uint> prevPageTable;
StructuredBuffer<uint> prevPageFlags;
StructuredBuffer<VSMPhysPageMetaData> prevPhysPageMetaData;
StructuredBuffer<VSMProjData> prevProjData;

RWStructuredBuffer<uint> outPageTable;
RWStructuredBuffer<uint> outPageFlags;
RWStructuredBuffer<VSMPhysPageMetaData> outPhysPageMetaData;
RWStructuredBuffer<VSMProjData> outProjData;
RWStructuredBuffer<uint> outPageRequestFlags;
RWStructuredBuffer<uint4> outPageRect;
RWStructuredBuffer<uint> outFreePhysPages;
RWStructuredBuffer<VSMPhysPageRequest> outPhysPageAllocRequests;
RWStructuredBuffer<uint4> outAllocPageRect;

DEF_TEX2D_AUTO(physPagePool);
RWTexture2D<float> outPhysPagePool;

VSMProjData getVSMProjData(uint vsmID)
{
    return projData[vsmID];
}

VSMPhysPage vsmGetPhysicalPage(uint pageOffset)
{
	return vsmDecodePageTable(pageTable[pageOffset]);
}

uint vsmGetPageFlags(uint vsmID, uint mipLevel, uint hMipLevel, uint2 pageAddress)
{
	uint mipToSample = mipLevel + hMipLevel;
	//uint hPageLevelOffset = CalcPageTableLevelOffset(vsmID, mipToSample);
	uint rawFlags = pageFlags[calcPageOffset(vsmID, mipToSample, pageAddress)];

	// Extract the flags for the given HMip
	uint hMipBitShift = VSM_PAGE_FLAGS_BITS_PER_HMIP * hMipLevel;
	return (rawFlags >> hMipBitShift) & VSM_PAGE_FLAGS_BITS_MASK;
}

uint4 getPageRect(ScreenRect rect)
{
	uint4 rectPages = uint4(rect.pixels) >> VSM_LOG2_PAGE_SIZE;

	return rectPages;
}

uint4 clipPageRect(uint4 rectPages, uint vsmID, uint mipLevel)
{
	uint4 rect = pageRect[vsmID * VSM_MAX_MIPS + mipLevel];

	return uint4(max(rectPages.xy, rect.xy), min(rectPages.zw, rect.zw));
}

uint4 getPageRect(ScreenRect rect, uint vsmID, uint mipLevel)
{
	return clipPageRect(getPageRect(rect), vsmID, mipLevel);
}

bool overlapsAnyValidPage(
	uint vsmID,
	uint mipLevel, 
	uint4 rectPages,
	uint flagMask = VSM_ALLOCATED_FLAG)
{
	if (any(rectPages.zw < rectPages.xy))
		return false;

	uint hMipLevel = calcMipLevel(rectPages, 2);

	rectPages >>= hMipLevel;
	for( uint y = rectPages.y; y <= rectPages.w; y++ )
	{
		for( uint x = rectPages.x; x <= rectPages.z; x++ )
		{
			uint pageFlags = vsmGetPageFlags(vsmID, mipLevel, hMipLevel, uint2(x, y));
			if ((pageFlags & flagMask) == flagMask)
			{
				return true;
			}
		}
	}

	return false;
}

float calcClipRadius(in TransformData data, float4x4 viewToClip)
{
    return data.localRadius * data.worldScale * viewToClip[0][0];
}

struct VSMDrawInstanceInfo
{
	uint instanceID;
};

struct ShadowViewInfo
{
	int4 viewRect;
	uint vsmID;
	uint mipLevel;
	uint mipCount;
	uint flags;
};

struct VisiableInstanceInfo
{
	uint viewIndex;
	VSMDrawInstanceInfo drawInfo;
	uint indirectArgIndex;
};