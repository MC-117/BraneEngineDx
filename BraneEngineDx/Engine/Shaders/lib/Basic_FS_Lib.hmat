#include "Const_Def.hmat"
#include "Bindings_Def.hmat"
#include "Basic_VS_Lib.hmat"
#define FS_DEF_OUT_BEGIN struct FragmentOut {
#define FS_DEF_OUT_END };
#define FS_DEF_OUT_COLOR(col, id) float4 col : SV_TARGET##id
#define DEFAULT_FS_MAIN main(DefaultVertexOut fin)

float3x3 cotangent(float3 N, float3 p, float2 uv)
{
    float3 dp1 = ddx(p);
    float3 dp2 = ddy(p);
    float2 duv1 = ddx(uv);
    float2 duv2 = ddy(uv);

    float3 dp2perp = cross(dp2, N);
    float3 dp1perp = cross(N, dp1);
    float3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    float3 B = dp2perp * duv1.y + dp1perp * duv2.y;

    float invmax = rsqrt(max(dot(T,T), dot(B,B)));
    return float3x3( T * invmax, B * invmax, N );
}

float fresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float3 fresnelSchlick(float cosTheta, float3 F0, float roughness)
{
    float r = 1.0 - roughness;
    return F0 + (max(float3(r, r, r), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}

float ShadowCalculation(in Texture2D depthMap, in SamplerState depthMapSampler, float4 fragPosLightSpace, float3 N, float3 L)
{
    float3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

    if (projCoords.z >= 1.0) {
        return 1.0;
    }
    
    projCoords = projCoords * 0.5 + 0.5;

    float currentDepth = projCoords.z;
    
    float shadow = 0.0;
    float bias = 0;//max(0.0000005 * (1.0 - dot(N, L)), 0.00000005);

    float2 texelSize;
    depthMap.GetDimensions(texelSize.x, texelSize.y);
    texelSize = 1.0 / texelSize;
    for(int x = -3; x <= 3; ++x)
    {
        for(int y = -3; y <= 3; ++y)
        {
            float pcfDepth = SAMPLE_TEX(depthMap, projCoords.xy + float2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 0.0 : 1.0;        
        }
    }
    shadow /= 49.0;
    return shadow;
}

float2 sphereProj(float3 v)
{
    float3 zp = normalize(float3(v.xy, 0.0f));
    float s = v.y >= 0 ? (0.25 - zp.x * 0.25) : (0.75 + zp.x * 0.25);
    float tp = dot(zp, v);
    float t = v.z >= 0 ? (1 - tp * 0.5) : (tp * 0.5);
    return float2(s, t);
}